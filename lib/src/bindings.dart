// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/ZeroTierSockets.h`.
///
/// Regenerate bindings with `flutter pub run ffigen --config ffigen.yaml`.
///
class ZeroTierNative {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  ZeroTierNative(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  ZeroTierNative.fromLookup(ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup) : _lookup = lookup;

  /// Error variable set after each `zts_*` socket call. Provides additional error context.
  late final ffi.Pointer<ffi.Int> _zts_errno = _lookup<ffi.Int>('zts_errno');

  int get zts_errno => _zts_errno.value;

  set zts_errno(int value) => _zts_errno.value = value;

  void __va_start(
    ffi.Pointer<va_list> arg0,
  ) {
    return ___va_start(
      arg0,
    );
  }

  late final ___va_startPtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<va_list>)>>('__va_start');
  late final ___va_start = ___va_startPtr.asFunction<void Function(ffi.Pointer<va_list>)>();

  void __security_init_cookie() {
    return ___security_init_cookie();
  }

  late final ___security_init_cookiePtr = _lookup<ffi.NativeFunction<ffi.Void Function()>>('__security_init_cookie');
  late final ___security_init_cookie = ___security_init_cookiePtr.asFunction<void Function()>();

  void __security_check_cookie(
    int _StackCookie,
  ) {
    return ___security_check_cookie(
      _StackCookie,
    );
  }

  late final ___security_check_cookiePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UintPtr)>>('__security_check_cookie');
  late final ___security_check_cookie = ___security_check_cookiePtr.asFunction<void Function(int)>();

  void __report_gsfailure(
    int _StackCookie,
  ) {
    return ___report_gsfailure(
      _StackCookie,
    );
  }

  late final ___report_gsfailurePtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UintPtr)>>('__report_gsfailure');
  late final ___report_gsfailure = ___report_gsfailurePtr.asFunction<void Function(int)>();

  late final ffi.Pointer<ffi.UintPtr> ___security_cookie = _lookup<ffi.UintPtr>('__security_cookie');

  int get __security_cookie => ___security_cookie.value;

  set __security_cookie(int value) => ___security_cookie.value = value;

  /// @brief Generates a node identity (public/secret key-pair) and stores it in a
  /// user-provided buffer.
  ///
  /// @param key User-provided destination buffer
  /// @param key_buf_len Length of user-provided destination buffer. Will be set
  /// to the number of bytes copied.
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument.
  int id_new(
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.UnsignedInt> key_buf_len,
  ) {
    return _id_new(
      key,
      key_buf_len,
    );
  }

  late final _id_newPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>)>>('zts_id_new');
  late final _id_new = _id_newPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// @brief Verifies that a key-pair is valid. Checks formatting and pairing of
  /// key to address.
  ///
  /// @param key Buffer containing key-pair
  /// @param len Length of key-pair buffer
  /// @return `1` if true, `0` if false.
  int id_pair_is_valid(
    ffi.Pointer<ffi.Char> key,
    int len,
  ) {
    return _id_pair_is_valid(
      key,
      len,
    );
  }

  late final _id_pair_is_validPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('zts_id_pair_is_valid');
  late final _id_pair_is_valid = _id_pair_is_validPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// @brief Instruct ZeroTier to look for node identity files at the given location. This is an
  /// initialization function that can only be called before `zts_node_start()`.
  ///
  /// Note that calling this function is not mandatory and if it is not called the node's keys will be
  /// kept in memory and retrievable via `zts_node_get_id_pair()`.
  ///
  /// See also: `zts_init_from_memory()`
  ///
  /// @param port Path Null-terminated file-system path string
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int init_from_storage(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _init_from_storage(
      path,
    );
  }

  late final _init_from_storagePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>('zts_init_from_storage');
  late final _init_from_storage = _init_from_storagePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// @brief Instruct ZeroTier to use the identity provided in `key`. This is an initialization
  /// function that can only be called before `zts_node_start()`.
  ///
  /// Note that calling this function is not mandatory and if it is not called the node's keys will be
  /// kept in memory and retrievable via `zts_node_get_id_pair()`.
  ///
  /// See also: `zts_init_from_storage()`
  ///
  /// @param key Buffer containing identity key
  /// @param len Length of `key` buffer
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int init_from_memory(
    ffi.Pointer<ffi.Char> key,
    int len,
  ) {
    return _init_from_memory(
      key,
      len,
    );
  }

  late final _init_from_memoryPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('zts_init_from_memory');
  late final _init_from_memory = _init_from_memoryPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int init_set_event_handler(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>> callback,
  ) {
    return _init_set_event_handler(
      callback,
    );
  }

  late final _init_set_event_handlerPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>>(
          'zts_init_set_event_handler');
  late final _init_set_event_handler =
      _init_set_event_handlerPtr.asFunction<int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  /// @brief Blacklist an interface prefix (or name). This prevents ZeroTier from
  /// sending traffic over matching interfaces. This is an initialization function that can
  /// only be called before `zts_node_start()`.
  ///
  /// @param prefix Null-terminated interface prefix string
  /// @param len Length of prefix string
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int init_blacklist_if(
    ffi.Pointer<ffi.Char> prefix,
    int len,
  ) {
    return _init_blacklist_if(
      prefix,
      len,
    );
  }

  late final _init_blacklist_ifPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('zts_init_blacklist_if');
  late final _init_blacklist_if = _init_blacklist_ifPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// @brief Present a root set definition for ZeroTier to use instead of the default.
  /// This is an initialization function that can only be called before `zts_node_start()`.
  ///
  /// @param roots_data Array of roots definition data (binary)
  /// @param len Length of binary data
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int init_set_roots(
    ffi.Pointer<ffi.Void> roots_data,
    int len,
  ) {
    return _init_set_roots(
      roots_data,
      len,
    );
  }

  late final _init_set_rootsPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.UnsignedInt)>>('zts_init_set_roots');
  late final _init_set_roots = _init_set_rootsPtr.asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// @brief Set the port to which the node should bind. This is an initialization function that can
  /// only be called before `zts_node_start()`.
  ///
  /// @param port Port number
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int init_set_port(
    int port,
  ) {
    return _init_set_port(
      port,
    );
  }

  late final _init_set_portPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedShort)>>('zts_init_set_port');
  late final _init_set_port = _init_set_portPtr.asFunction<int Function(int)>();

  /// @brief Set range that random ports will be selected from. This is an initialization function that can
  /// only be called before `zts_node_start()`.
  ///
  /// @param start_port Start of port range
  /// @param end_port End of port range
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int init_set_random_port_range(
    int start_port,
    int end_port,
  ) {
    return _init_set_random_port_range(
      start_port,
      end_port,
    );
  }

  late final _init_set_random_port_rangePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedShort, ffi.UnsignedShort)>>('zts_init_set_random_port_range');
  late final _init_set_random_port_range = _init_set_random_port_rangePtr.asFunction<int Function(int, int)>();

  /// @brief Allow or disallow ZeroTier from automatically selecting a backup port to help get through
  /// buggy NAT. This is enabled by default. This port is randomly chosen and should be disabled if you
  /// want to control exactly which ports ZeroTier talks on and (iff) you know with absolute certainty
  /// that traffic on your chosen primary port is allowed. This is an initialization function that can
  /// only be called before `zts_node_start()`.
  ///
  /// @param allowed Whether or not this feature is enabled
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int init_allow_secondary_port(
    int allowed,
  ) {
    return _init_allow_secondary_port(
      allowed,
    );
  }

  late final _init_allow_secondary_portPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>('zts_init_allow_secondary_port');
  late final _init_allow_secondary_port = _init_allow_secondary_portPtr.asFunction<int Function(int)>();

  /// @brief Allow or disallow the use of port-mapping. This is enabled by default. This is an
  /// initialization function that can only be called before `zts_node_start()`.
  ///
  /// @param allowed Whether or not this feature is enabled
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int init_allow_port_mapping(
    int allowed,
  ) {
    return _init_allow_port_mapping(
      allowed,
    );
  }

  late final _init_allow_port_mappingPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>('zts_init_allow_port_mapping');
  late final _init_allow_port_mapping = _init_allow_port_mappingPtr.asFunction<int Function(int)>();

  /// @brief Enable or disable whether the node will cache network details
  /// (enabled by default when `zts_init_from_storage()` is used.) Must be called before
  /// `zts_node_start()`.
  ///
  /// This can potentially shorten (startup) times between node restarts. This allows the service to
  /// nearly instantly inform the network stack of an address to use for this peer
  /// so that it can create a transport service. This can be disabled for cases where one
  /// may not want network config details to be written to storage. This is
  /// especially useful for situations where address assignments do not change
  /// often.
  ///
  /// See also: `zts_init_allow_peer_cache()`
  ///
  /// @param allowed Whether or not this feature is enabled
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int init_allow_net_cache(
    int allowed,
  ) {
    return _init_allow_net_cache(
      allowed,
    );
  }

  late final _init_allow_net_cachePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>('zts_init_allow_net_cache');
  late final _init_allow_net_cache = _init_allow_net_cachePtr.asFunction<int Function(int)>();

  /// @brief Enable or disable whether the node will cache peer details (enabled
  /// by default when `zts_init_from_storage()` is used.) Must be called before `zts_node_start()`.
  ///
  /// This can potentially shorten (connection) times between node restarts. This allows the service to
  /// re-use previously discovered paths to a peer, this prevents the service from
  /// having to go through the entire transport-triggered link provisioning
  /// process. This is especially useful for situations where paths to peers do not
  /// change often. This is enabled by default and can be disabled for cases where
  /// one may not want peer details to be written to storage.
  ///
  /// See also: `zts_init_allow_net_cache()`
  ///
  /// @param allowed Whether or not this feature is enabled
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int init_allow_peer_cache(
    int allowed,
  ) {
    return _init_allow_peer_cache(
      allowed,
    );
  }

  late final _init_allow_peer_cachePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>('zts_init_allow_peer_cache');
  late final _init_allow_peer_cache = _init_allow_peer_cachePtr.asFunction<int Function(int)>();

  /// @brief Enable or disable whether the node will cache root definitions (enabled
  /// by default when `zts_init_from_storage()` is used.) Must be called before `zts_node_start()`.
  ///
  /// @param allowed Whether or not this feature is enabled
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int init_allow_roots_cache(
    int allowed,
  ) {
    return _init_allow_roots_cache(
      allowed,
    );
  }

  late final _init_allow_roots_cachePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>('zts_init_allow_roots_cache');
  late final _init_allow_roots_cache = _init_allow_roots_cachePtr.asFunction<int Function(int)>();

  /// @brief Enable or disable whether the node will cache identities (enabled
  /// by default when `zts_init_from_storage()` is used.) Must be called before `zts_node_start()`.
  ///
  /// @param allowed Whether or not this feature is enabled
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int init_allow_id_cache(
    int allowed,
  ) {
    return _init_allow_id_cache(
      allowed,
    );
  }

  late final _init_allow_id_cachePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>('zts_init_allow_id_cache');
  late final _init_allow_id_cache = _init_allow_id_cachePtr.asFunction<int Function(int)>();

  /// @brief Return whether an address of the given family has been assigned by the network
  ///
  /// @param net_id Network ID
  /// @param family `ZTS_AF_INET`, or `ZTS_AF_INET6`
  /// @return `1` if true, `0` if false.
  int addr_is_assigned(
    int net_id,
    int family,
  ) {
    return _addr_is_assigned(
      net_id,
      family,
    );
  }

  late final _addr_is_assignedPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.UnsignedInt)>>('zts_addr_is_assigned');
  late final _addr_is_assigned = _addr_is_assignedPtr.asFunction<int Function(int, int)>();

  /// @brief Get the first-assigned IP on the given network.
  ///
  /// To get *all* assigned addresses on a given network, use `zts_addr_get_all()`.
  ///
  /// @param net_id Network ID
  /// @param family `ZTS_AF_INET`, or `ZTS_AF_INET6`
  /// @param addr Destination buffer to hold address
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int addr_get(
    int net_id,
    int family,
    ffi.Pointer<zts_sockaddr_storage> addr,
  ) {
    return _addr_get(
      net_id,
      family,
      addr,
    );
  }

  late final _addr_getPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.UnsignedInt, ffi.Pointer<zts_sockaddr_storage>)>>('zts_addr_get');
  late final _addr_get = _addr_getPtr.asFunction<int Function(int, int, ffi.Pointer<zts_sockaddr_storage>)>();

  /// @brief Get the first-assigned IP on the given network as a null-terminated human-readable string
  ///
  /// To get *all* assigned addresses on a given network, use `zts_addr_get_all()`.
  ///
  /// @param net_id Network ID
  /// @param family `ZTS_AF_INET`, or `ZTS_AF_INET6`
  /// @param dst Destination buffer
  /// @param len Length of destination buffer (must be exactly `ZTS_IP_MAX_STR_LEN`)
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int addr_get_str(
    int net_id,
    int family,
    ffi.Pointer<ffi.Char> dst,
    int len,
  ) {
    return _addr_get_str(
      net_id,
      family,
      dst,
      len,
    );
  }

  late final _addr_get_strPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('zts_addr_get_str');
  late final _addr_get_str = _addr_get_strPtr.asFunction<int Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Get all IP addresses assigned to this node by the given network
  ///
  /// @param net_id Network ID
  /// @param addr Destination buffer to hold address
  /// @param count Number of addresses returned
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int addr_get_all(
    int net_id,
    ffi.Pointer<zts_sockaddr_storage> addr,
    ffi.Pointer<ffi.UnsignedInt> count,
  ) {
    return _addr_get_all(
      net_id,
      addr,
      count,
    );
  }

  late final _addr_get_allPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.Pointer<zts_sockaddr_storage>, ffi.Pointer<ffi.UnsignedInt>)>>('zts_addr_get_all');
  late final _addr_get_all = _addr_get_allPtr.asFunction<int Function(int, ffi.Pointer<zts_sockaddr_storage>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// @brief Compute a `6PLANE` IPv6 address for the given Network ID and Node ID
  ///
  /// @param net_id Network ID
  /// @param node_id Node ID
  /// @param addr Destination structure for address
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument.
  int addr_compute_6plane(
    int net_id,
    int node_id,
    ffi.Pointer<zts_sockaddr_storage> addr,
  ) {
    return _addr_compute_6plane(
      net_id,
      node_id,
      addr,
    );
  }

  late final _addr_compute_6planePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.Uint64, ffi.Pointer<zts_sockaddr_storage>)>>('zts_addr_compute_6plane');
  late final _addr_compute_6plane = _addr_compute_6planePtr.asFunction<int Function(int, int, ffi.Pointer<zts_sockaddr_storage>)>();

  /// @brief Compute `RFC4193` IPv6 address for the given Network ID and Node ID
  ///
  /// @param net_id Network ID
  /// @param node_id Node ID
  /// @param addr Destination structure for address
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument.
  int addr_compute_rfc4193(
    int net_id,
    int node_id,
    ffi.Pointer<zts_sockaddr_storage> addr,
  ) {
    return _addr_compute_rfc4193(
      net_id,
      node_id,
      addr,
    );
  }

  late final _addr_compute_rfc4193Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.Uint64, ffi.Pointer<zts_sockaddr_storage>)>>('zts_addr_compute_rfc4193');
  late final _addr_compute_rfc4193 = _addr_compute_rfc4193Ptr.asFunction<int Function(int, int, ffi.Pointer<zts_sockaddr_storage>)>();

  /// @brief Compute `RFC4193` IPv6 address for the given Network ID and Node ID and copy its
  /// null-terminated human-readable string representation into destination buffer.
  ///
  /// @param net_id Network ID
  /// @param node_id Node ID
  /// @param dst Destination string buffer
  /// @param len Length of destination string buffer (must be exactly `ZTS_IP_MAX_STR_LEN`)
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument.
  int addr_compute_rfc4193_str(
    int net_id,
    int node_id,
    ffi.Pointer<ffi.Char> dst,
    int len,
  ) {
    return _addr_compute_rfc4193_str(
      net_id,
      node_id,
      dst,
      len,
    );
  }

  late final _addr_compute_rfc4193_strPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.Uint64, ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('zts_addr_compute_rfc4193_str');
  late final _addr_compute_rfc4193_str = _addr_compute_rfc4193_strPtr.asFunction<int Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Compute `6PLANE` IPv6 address for the given Network ID and Node ID and copy its
  /// null-terminated human-readable string representation into destination buffer.
  ///
  /// @param net_id Network ID
  /// @param node_id Node ID
  /// @param dst Destination string buffer
  /// @param len Length of destination string buffer (must be exactly `ZTS_IP_MAX_STR_LEN`)
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument.
  int addr_compute_6plane_str(
    int net_id,
    int node_id,
    ffi.Pointer<ffi.Char> dst,
    int len,
  ) {
    return _addr_compute_6plane_str(
      net_id,
      node_id,
      dst,
      len,
    );
  }

  late final _addr_compute_6plane_strPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.Uint64, ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('zts_addr_compute_6plane_str');
  late final _addr_compute_6plane_str = _addr_compute_6plane_strPtr.asFunction<int Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Compute `RFC4193` IPv6 address for the given Network ID and Node ID
  ///
  /// Ad-hoc Network:
  /// ```
  /// ffSSSSEEEE000000
  /// | |   |   |
  /// | |   |   Reserved for future use, must be 0
  /// | |   End of port range (hex)
  /// | Start of port range (hex)
  /// Reserved ZeroTier address prefix indicating a controller-less network.
  /// ```
  /// Ad-hoc networks are public (no access control) networks that have no network
  /// controller. Instead their configuration and other credentials are generated
  /// locally. Ad-hoc networks permit only IPv6 UDP and TCP unicast traffic
  /// (no multicast or broadcast) using 6plane format NDP-emulated IPv6 addresses.
  /// In addition an ad-hoc network ID encodes an IP port range. UDP packets and
  /// TCP SYN (connection open) packets are only allowed to destination ports
  /// within the encoded range.
  ///
  /// For example `ff00160016000000` is an ad-hoc network allowing only SSH,
  /// while `ff0000ffff000000` is an ad-hoc network allowing any UDP or TCP port.
  ///
  /// Keep in mind that these networks are public and anyone in the entire world
  /// can join them. Care must be taken to avoid exposing vulnerable services or
  /// sharing unwanted files or other resources.
  ///
  ///
  /// @param start_port Start of port allowed port range
  /// @param end_port End of allowed port range
  /// @return An Ad-hoc network ID
  int net_compute_adhoc_id(
    int start_port,
    int end_port,
  ) {
    return _net_compute_adhoc_id(
      start_port,
      end_port,
    );
  }

  late final _net_compute_adhoc_idPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Uint16, ffi.Uint16)>>('zts_net_compute_adhoc_id');
  late final _net_compute_adhoc_id = _net_compute_adhoc_idPtr.asFunction<int Function(int, int)>();

  /// @brief Join a network
  ///
  /// @param net_id Network ID
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int net_join(
    int net_id,
  ) {
    return _net_join(
      net_id,
    );
  }

  late final _net_joinPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('zts_net_join');
  late final _net_join = _net_joinPtr.asFunction<int Function(int)>();

  /// @brief Leave a network
  ///
  /// @param net_id Network ID
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int net_leave(
    int net_id,
  ) {
    return _net_leave(
      net_id,
    );
  }

  late final _net_leavePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('zts_net_leave');
  late final _net_leave = _net_leavePtr.asFunction<int Function(int)>();

  /// @brief Return whether this network is ready to send and receive traffic.
  ///
  /// @return `1` if true, `0` if false.
  int net_transport_is_ready(
    int net_id,
  ) {
    return _net_transport_is_ready(
      net_id,
    );
  }

  late final _net_transport_is_readyPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('zts_net_transport_is_ready');
  late final _net_transport_is_ready = _net_transport_is_readyPtr.asFunction<int Function(int)>();

  /// @brief Get the MAC Address for this node on the given network
  ///
  /// @param net_id Network ID
  ///
  /// @return MAC address in numerical format
  int net_get_mac(
    int net_id,
  ) {
    return _net_get_mac(
      net_id,
    );
  }

  late final _net_get_macPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Uint64)>>('zts_net_get_mac');
  late final _net_get_mac = _net_get_macPtr.asFunction<int Function(int)>();

  /// @brief Get the MAC Address for this node on the given network
  ///
  /// @param net_id Network ID
  /// @param dst Destination string buffer
  /// @param len Length of destination string buffer. Must be exactly `ZTS_MAC_ADDRSTRLEN`
  ///
  /// @return MAC address in string format
  int net_get_mac_str(
    int net_id,
    ffi.Pointer<ffi.Char> dst,
    int len,
  ) {
    return _net_get_mac_str(
      net_id,
      dst,
      len,
    );
  }

  late final _net_get_mac_strPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('zts_net_get_mac_str');
  late final _net_get_mac_str = _net_get_mac_strPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Return whether broadcast is enabled on this network
  ///
  /// @param net_id Network ID
  ///
  /// @return `1` if true, `0` if false.
  int net_get_broadcast(
    int net_id,
  ) {
    return _net_get_broadcast(
      net_id,
    );
  }

  late final _net_get_broadcastPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('zts_net_get_broadcast');
  late final _net_get_broadcast = _net_get_broadcastPtr.asFunction<int Function(int)>();

  /// @brief Get the MTU of the given network
  ///
  /// @param net_id Network ID
  ///
  /// @return MTU
  int net_get_mtu(
    int net_id,
  ) {
    return _net_get_mtu(
      net_id,
    );
  }

  late final _net_get_mtuPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('zts_net_get_mtu');
  late final _net_get_mtu = _net_get_mtuPtr.asFunction<int Function(int)>();

  /// @brief Get the nickname of the network
  ///
  /// @param net_id Network ID
  /// @param dst Destination string buffer
  /// @param len Length of destination string buffer
  ///
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int net_get_name(
    int net_id,
    ffi.Pointer<ffi.Char> dst,
    int len,
  ) {
    return _net_get_name(
      net_id,
      dst,
      len,
    );
  }

  late final _net_get_namePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('zts_net_get_name');
  late final _net_get_name = _net_get_namePtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Get the status of the network
  ///
  /// @param net_id Network ID
  ///
  /// @return Status
  int net_get_status(
    int net_id,
  ) {
    return _net_get_status(
      net_id,
    );
  }

  late final _net_get_statusPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('zts_net_get_status');
  late final _net_get_status = _net_get_statusPtr.asFunction<int Function(int)>();

  /// @brief Get the type of network (public or private.)
  ///
  /// @param net_id Network ID
  ///
  /// @return Type
  int net_get_type(
    int net_id,
  ) {
    return _net_get_type(
      net_id,
    );
  }

  late final _net_get_typePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('zts_net_get_type');
  late final _net_get_type = _net_get_typePtr.asFunction<int Function(int)>();

  /// @brief Return whether a managed route of the given address family has been assigned by the
  /// network
  ///
  /// @param net_id Network ID
  /// @param family `ZTS_AF_INET`, or `ZTS_AF_INET6`
  /// @return `1` if true, `0` if false.
  int route_is_assigned(
    int net_id,
    int family,
  ) {
    return _route_is_assigned(
      net_id,
      family,
    );
  }

  late final _route_is_assignedPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.UnsignedInt)>>('zts_route_is_assigned');
  late final _route_is_assigned = _route_is_assignedPtr.asFunction<int Function(int, int)>();

  /// @brief Start the ZeroTier node. Should be called after calling the relevant
  /// `zts_init_*` functions for your application. To enable storage call
  /// `zts_init_from_storage()` before this function. To enable event callbacks
  /// call `zts_init_set_event_handler()` before this function.
  ///
  /// Note: If neither `zts_init_from_storage()` or `zts_init_from_memory()` are
  /// called a new identity will be generated and will be retrievable via
  /// `zts_node_get_id_pair()` *after* the node has started.
  ///
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem.
  int node_start() {
    return _node_start();
  }

  late final _node_startPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('zts_node_start');
  late final _node_start = _node_startPtr.asFunction<int Function()>();

  /// @brief Return whether the node is online (Can reach the Internet)
  ///
  /// @return `1` if true, `0` if false.
  int node_is_online() {
    return _node_is_online();
  }

  late final _node_is_onlinePtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('zts_node_is_online');
  late final _node_is_online = _node_is_onlinePtr.asFunction<int Function()>();

  /// @brief Get the public node identity (aka `node_id`). Callable only after the node has been
  /// started.
  ///
  /// @return Identity in numerical form
  int node_get_id() {
    return _node_get_id();
  }

  late final _node_get_idPtr = _lookup<ffi.NativeFunction<ffi.Uint64 Function()>>('zts_node_get_id');
  late final _node_get_id = _node_get_idPtr.asFunction<int Function()>();

  /// @brief Copy the current node's public (and secret!) identity into a buffer.
  ///
  /// `WARNING`: This function exports your secret key and should be used carefully.
  ///
  /// @param key User-provided destination buffer
  /// @param key_dst_len Length of user-provided destination buffer. Will be set to
  /// number of bytes copied.
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int node_get_id_pair(
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.UnsignedInt> key_dst_len,
  ) {
    return _node_get_id_pair(
      key,
      key_dst_len,
    );
  }

  late final _node_get_id_pairPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>)>>('zts_node_get_id_pair');
  late final _node_get_id_pair = _node_get_id_pairPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// @brief Get the primary port to which the node is bound. Callable only after the node has been
  /// started.
  ///
  /// @return Port number
  int node_get_port() {
    return _node_get_port();
  }

  late final _node_get_portPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('zts_node_get_port');
  late final _node_get_port = _node_get_portPtr.asFunction<int Function()>();

  /// @brief Stop the ZeroTier node and bring down all virtual network
  /// transport services. Callable only after the node has been started.
  ///
  /// While the ZeroTier will stop, the stack driver (with associated
  /// timers) will remain active in case future traffic processing is required.
  /// To stop all activity and free all resources use `zts_free()` instead.
  ///
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem.
  int node_stop() {
    return _node_stop();
  }

  late final _node_stopPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('zts_node_stop');
  late final _node_stop = _node_stopPtr.asFunction<int Function()>();

  /// @brief Stop all background threads, bring down all transport services, free all
  /// resources. After calling this function an application restart will be
  /// required before the library can be used again. Callable only after the node
  /// has been started.
  ///
  /// This should be called at the end of your program or when you do not
  /// anticipate communicating over ZeroTier again.
  ///
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem.
  int node_free() {
    return _node_free();
  }

  late final _node_freePtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('zts_node_free');
  late final _node_free = _node_freePtr.asFunction<int Function()>();

  /// @brief Orbit a given moon (user-defined root server)
  ///
  /// @param moon_roots_id World ID
  /// @param moon_seed Seed ID
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int moon_orbit(
    int moon_roots_id,
    int moon_seed,
  ) {
    return _moon_orbit(
      moon_roots_id,
      moon_seed,
    );
  }

  late final _moon_orbitPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.Uint64)>>('zts_moon_orbit');
  late final _moon_orbit = _moon_orbitPtr.asFunction<int Function(int, int)>();

  /// @brief De-orbit a given moon (user-defined root server)
  ///
  /// @param moon_roots_id World ID
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int moon_deorbit(
    int moon_roots_id,
  ) {
    return _moon_deorbit(
      moon_roots_id,
    );
  }

  late final _moon_deorbitPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('zts_moon_deorbit');
  late final _moon_deorbit = _moon_deorbitPtr.asFunction<int Function(int)>();

  /// @brief Get all statistical counters for all protocols and levels.
  /// See also: lwip/stats.h.
  ///
  /// This function can only be used in debug builds.
  ///
  /// @param dst Pointer to structure that will be populated with statistics
  ///
  /// @return ZTS_ERR_OK on success. ZTS_ERR_ARG or ZTS_ERR_NO_RESULT on failure.
  int stats_get_all(
    ffi.Pointer<zts_stats_counter_t> dst,
  ) {
    return _stats_get_all(
      dst,
    );
  }

  late final _stats_get_allPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<zts_stats_counter_t>)>>('zts_stats_get_all');
  late final _stats_get_all = _stats_get_allPtr.asFunction<int Function(ffi.Pointer<zts_stats_counter_t>)>();

  /// @brief Create a socket
  ///
  /// @param family `ZTS_AF_INET` or `ZTS_AF_INET6`
  /// @param type `ZTS_SOCK_STREAM` or `ZTS_SOCK_DGRAM`
  /// @param protocol Protocols supported on this socket
  /// @return Numbered file descriptor on success, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_socket(
    int family,
    int type,
    int protocol,
  ) {
    return _bsd_socket(
      family,
      type,
      protocol,
    );
  }

  late final _bsd_socketPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>('zts_bsd_socket');
  late final _bsd_socket = _bsd_socketPtr.asFunction<int Function(int, int, int)>();

  /// @brief Connect a socket to a remote host
  ///
  /// @param fd Socket file descriptor
  /// @param addr Remote host address to connect to
  /// @param addrlen Length of address
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_connect(
    int fd,
    ffi.Pointer<zts_sockaddr> addr,
    int addrlen,
  ) {
    return _bsd_connect(
      fd,
      addr,
      addrlen,
    );
  }

  late final _bsd_connectPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<zts_sockaddr>, zts_socklen_t)>>('zts_bsd_connect');
  late final _bsd_connect = _bsd_connectPtr.asFunction<int Function(int, ffi.Pointer<zts_sockaddr>, int)>();

  /// @brief Bind a socket to a local address
  ///
  /// @param fd Socket file descriptor
  /// @param addr Local interface address to bind to
  /// @param addrlen Length of address
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_bind(
    int fd,
    ffi.Pointer<zts_sockaddr> addr,
    int addrlen,
  ) {
    return _bsd_bind(
      fd,
      addr,
      addrlen,
    );
  }

  late final _bsd_bindPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<zts_sockaddr>, zts_socklen_t)>>('zts_bsd_bind');
  late final _bsd_bind = _bsd_bindPtr.asFunction<int Function(int, ffi.Pointer<zts_sockaddr>, int)>();

  /// @brief Listen for incoming connections on socket
  ///
  /// @param fd Socket file descriptor
  /// @param backlog Number of backlogged connections allowed
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_listen(
    int fd,
    int backlog,
  ) {
    return _bsd_listen(
      fd,
      backlog,
    );
  }

  late final _bsd_listenPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('zts_bsd_listen');
  late final _bsd_listen = _bsd_listenPtr.asFunction<int Function(int, int)>();

  /// @brief Accept an incoming connection
  ///
  /// @param fd Socket file descriptor
  /// @param addr Address of remote host for accepted connection
  /// @param addrlen Length of address
  /// @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_accept(
    int fd,
    ffi.Pointer<zts_sockaddr> addr,
    ffi.Pointer<zts_socklen_t> addrlen,
  ) {
    return _bsd_accept(
      fd,
      addr,
      addrlen,
    );
  }

  late final _bsd_acceptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<zts_sockaddr>, ffi.Pointer<zts_socklen_t>)>>('zts_bsd_accept');
  late final _bsd_accept = _bsd_acceptPtr.asFunction<int Function(int, ffi.Pointer<zts_sockaddr>, ffi.Pointer<zts_socklen_t>)>();

  /// @brief Set socket options.
  ///
  /// @param fd Socket file descriptor
  /// @param level Protocol level to which option name should apply
  /// @param optname Option name to set
  /// @param optval Source of option value to set
  /// @param optlen Length of option value
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_setsockopt(
    int fd,
    int level,
    int optname,
    ffi.Pointer<ffi.Void> optval,
    int optlen,
  ) {
    return _bsd_setsockopt(
      fd,
      level,
      optname,
      optval,
      optlen,
    );
  }

  late final _bsd_setsockoptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>, zts_socklen_t)>>('zts_bsd_setsockopt');
  late final _bsd_setsockopt = _bsd_setsockoptPtr.asFunction<int Function(int, int, int, ffi.Pointer<ffi.Void>, int)>();

  /// @brief Get socket options.
  ///
  /// @param fd Socket file descriptor
  /// @param level Protocol level to which option name should apply
  /// @param optname Option name to get
  /// @param optval Where option value will be stored
  /// @param optlen Length of value
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_getsockopt(
    int fd,
    int level,
    int optname,
    ffi.Pointer<ffi.Void> optval,
    ffi.Pointer<zts_socklen_t> optlen,
  ) {
    return _bsd_getsockopt(
      fd,
      level,
      optname,
      optval,
      optlen,
    );
  }

  late final _bsd_getsockoptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>, ffi.Pointer<zts_socklen_t>)>>(
          'zts_bsd_getsockopt');
  late final _bsd_getsockopt = _bsd_getsockoptPtr.asFunction<int Function(int, int, int, ffi.Pointer<ffi.Void>, ffi.Pointer<zts_socklen_t>)>();

  /// @brief Get the name (address) of the local end of the socket
  ///
  /// @param fd Socket file descriptor
  /// @param addr Name associated with this socket
  /// @param addrlen Length of name
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_getsockname(
    int fd,
    ffi.Pointer<zts_sockaddr> addr,
    ffi.Pointer<zts_socklen_t> addrlen,
  ) {
    return _bsd_getsockname(
      fd,
      addr,
      addrlen,
    );
  }

  late final _bsd_getsocknamePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<zts_sockaddr>, ffi.Pointer<zts_socklen_t>)>>('zts_bsd_getsockname');
  late final _bsd_getsockname = _bsd_getsocknamePtr.asFunction<int Function(int, ffi.Pointer<zts_sockaddr>, ffi.Pointer<zts_socklen_t>)>();

  /// @brief Get the name (address) of the remote end of the socket
  ///
  /// @param fd Socket file descriptor
  /// @param addr Name associated with remote end of this socket
  /// @param addrlen Length of name
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_getpeername(
    int fd,
    ffi.Pointer<zts_sockaddr> addr,
    ffi.Pointer<zts_socklen_t> addrlen,
  ) {
    return _bsd_getpeername(
      fd,
      addr,
      addrlen,
    );
  }

  late final _bsd_getpeernamePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<zts_sockaddr>, ffi.Pointer<zts_socklen_t>)>>('zts_bsd_getpeername');
  late final _bsd_getpeername = _bsd_getpeernamePtr.asFunction<int Function(int, ffi.Pointer<zts_sockaddr>, ffi.Pointer<zts_socklen_t>)>();

  /// @brief Close socket.
  ///
  /// @param fd Socket file descriptor
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_close(
    int fd,
  ) {
    return _bsd_close(
      fd,
    );
  }

  late final _bsd_closePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_bsd_close');
  late final _bsd_close = _bsd_closePtr.asFunction<int Function(int)>();

  /// @brief Monitor multiple file descriptors for "readiness"
  ///
  /// @param nfds Set to the highest numbered file descriptor in any of the given
  /// sets
  /// @param readfds Set of file descriptors to monitor for READ readiness
  /// @param writefds Set of file descriptors to monitor for WRITE readiness
  /// @param exceptfds Set of file descriptors to monitor for exceptional
  /// conditions
  /// @param timeout How long this call should block
  /// @return Number of ready file descriptors on success. `ZTS_ERR_SOCKET`,
  /// `ZTS_ERR_SERVICE` on failure. Sets `zts_errno`
  int bsd_select(
    int nfds,
    ffi.Pointer<zts_fd_set> readfds,
    ffi.Pointer<zts_fd_set> writefds,
    ffi.Pointer<zts_fd_set> exceptfds,
    ffi.Pointer<zts_timeval> timeout,
  ) {
    return _bsd_select(
      nfds,
      readfds,
      writefds,
      exceptfds,
      timeout,
    );
  }

  late final _bsd_selectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<zts_fd_set>, ffi.Pointer<zts_fd_set>, ffi.Pointer<zts_fd_set>, ffi.Pointer<zts_timeval>)>>('zts_bsd_select');
  late final _bsd_select = _bsd_selectPtr
      .asFunction<int Function(int, ffi.Pointer<zts_fd_set>, ffi.Pointer<zts_fd_set>, ffi.Pointer<zts_fd_set>, ffi.Pointer<zts_timeval>)>();

  /// @brief Issue file control commands on a socket
  ///
  /// @param fd Socket file descriptor
  /// @param cmd Operation to be performed
  /// @param flags Flags
  /// @return
  int bsd_fcntl(
    int fd,
    int cmd,
    int flags,
  ) {
    return _bsd_fcntl(
      fd,
      cmd,
      flags,
    );
  }

  late final _bsd_fcntlPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>('zts_bsd_fcntl');
  late final _bsd_fcntl = _bsd_fcntlPtr.asFunction<int Function(int, int, int)>();

  /// @brief Wait for some event on a file descriptor.
  ///
  /// @param fds Set of file descriptors to monitor
  /// @param nfds Number of elements in the fds array
  /// @param timeout How long this call should block
  /// @return Number of ready file descriptors if successful, `ZTS_ERR_SERVICE` if
  /// the node experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets
  /// `zts_errno`
  int bsd_poll(
    ffi.Pointer<zts_pollfd> fds,
    int nfds,
    int timeout,
  ) {
    return _bsd_poll(
      fds,
      nfds,
      timeout,
    );
  }

  late final _bsd_pollPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<zts_pollfd>, zts_nfds_t, ffi.Int)>>('zts_bsd_poll');
  late final _bsd_poll = _bsd_pollPtr.asFunction<int Function(ffi.Pointer<zts_pollfd>, int, int)>();

  /// @brief Control a device
  ///
  /// @param fd Socket file descriptor
  /// @param request Selects the control function to be performed
  /// @param argp Additional information
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_ioctl(
    int fd,
    int request,
    ffi.Pointer<ffi.Void> argp,
  ) {
    return _bsd_ioctl(
      fd,
      request,
      argp,
    );
  }

  late final _bsd_ioctlPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.UnsignedLong, ffi.Pointer<ffi.Void>)>>('zts_bsd_ioctl');
  late final _bsd_ioctl = _bsd_ioctlPtr.asFunction<int Function(int, int, ffi.Pointer<ffi.Void>)>();

  /// @brief Send data to remote host
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data to write
  /// @param flags (e.g. `ZTS_MSG_DONTWAIT`, `ZTS_MSG_MORE`)
  /// @return Number of bytes sent if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_send(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
    int flags,
  ) {
    return _bsd_send(
      fd,
      buf,
      len,
      flags,
    );
  }

  late final _bsd_sendPtr = _lookup<ffi.NativeFunction<ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, ffi.Int)>>('zts_bsd_send');
  late final _bsd_send = _bsd_sendPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  /// @brief Send data to remote host
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data to write
  /// @param flags Specifies type of message transmission
  /// @param addr Destination address
  /// @param addrlen Length of destination address
  /// @return Number of bytes sent if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_sendto(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
    int flags,
    ffi.Pointer<zts_sockaddr> addr,
    int addrlen,
  ) {
    return _bsd_sendto(
      fd,
      buf,
      len,
      flags,
      addr,
      addrlen,
    );
  }

  late final _bsd_sendtoPtr =
      _lookup<ffi.NativeFunction<ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, ffi.Int, ffi.Pointer<zts_sockaddr>, zts_socklen_t)>>(
          'zts_bsd_sendto');
  late final _bsd_sendto = _bsd_sendtoPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<zts_sockaddr>, int)>();

  /// @brief Send message to remote host
  ///
  /// @param fd Socket file descriptor
  /// @param msg Message to send
  /// @param flags Specifies type of message transmission
  /// @return Number of bytes sent if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_sendmsg(
    int fd,
    ffi.Pointer<zts_msghdr> msg,
    int flags,
  ) {
    return _bsd_sendmsg(
      fd,
      msg,
      flags,
    );
  }

  late final _bsd_sendmsgPtr = _lookup<ffi.NativeFunction<ssize_t Function(ffi.Int, ffi.Pointer<zts_msghdr>, ffi.Int)>>('zts_bsd_sendmsg');
  late final _bsd_sendmsg = _bsd_sendmsgPtr.asFunction<int Function(int, ffi.Pointer<zts_msghdr>, int)>();

  /// @brief Receive data from remote host
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data buffer
  /// @param flags Specifies the type of message receipt
  /// @return Number of bytes received if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_recv(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
    int flags,
  ) {
    return _bsd_recv(
      fd,
      buf,
      len,
      flags,
    );
  }

  late final _bsd_recvPtr = _lookup<ffi.NativeFunction<ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, ffi.Int)>>('zts_bsd_recv');
  late final _bsd_recv = _bsd_recvPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  /// @brief Receive data from remote host
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data buffer
  /// @param flags Specifies the type of message receipt
  /// @param addr Destination address buffer
  /// @param addrlen Length of destination address buffer
  /// @return Number of bytes received if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_recvfrom(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
    int flags,
    ffi.Pointer<zts_sockaddr> addr,
    ffi.Pointer<zts_socklen_t> addrlen,
  ) {
    return _bsd_recvfrom(
      fd,
      buf,
      len,
      flags,
      addr,
      addrlen,
    );
  }

  late final _bsd_recvfromPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, ffi.Int, ffi.Pointer<zts_sockaddr>, ffi.Pointer<zts_socklen_t>)>>('zts_bsd_recvfrom');
  late final _bsd_recvfrom =
      _bsd_recvfromPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<zts_sockaddr>, ffi.Pointer<zts_socklen_t>)>();

  /// @brief Receive a message from remote host
  ///
  /// @param fd Socket file descriptor
  /// @param msg Message that was received
  /// @param flags Specifies the type of message receipt
  /// @return Number of bytes received if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_recvmsg(
    int fd,
    ffi.Pointer<zts_msghdr> msg,
    int flags,
  ) {
    return _bsd_recvmsg(
      fd,
      msg,
      flags,
    );
  }

  late final _bsd_recvmsgPtr = _lookup<ffi.NativeFunction<ssize_t Function(ffi.Int, ffi.Pointer<zts_msghdr>, ffi.Int)>>('zts_bsd_recvmsg');
  late final _bsd_recvmsg = _bsd_recvmsgPtr.asFunction<int Function(int, ffi.Pointer<zts_msghdr>, int)>();

  /// @brief Read data from socket onto buffer
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data buffer to receive data
  /// @return Number of bytes read if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_read(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _bsd_read(
      fd,
      buf,
      len,
    );
  }

  late final _bsd_readPtr = _lookup<ffi.NativeFunction<ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('zts_bsd_read');
  late final _bsd_read = _bsd_readPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// @brief Read data from socket into multiple buffers
  ///
  /// @param fd Socket file descriptor
  /// @param iov Array of destination buffers
  /// @param iovcnt Number of buffers to read into
  /// @return Number of bytes read if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_readv(
    int fd,
    ffi.Pointer<zts_iovec> iov,
    int iovcnt,
  ) {
    return _bsd_readv(
      fd,
      iov,
      iovcnt,
    );
  }

  late final _bsd_readvPtr = _lookup<ffi.NativeFunction<ssize_t Function(ffi.Int, ffi.Pointer<zts_iovec>, ffi.Int)>>('zts_bsd_readv');
  late final _bsd_readv = _bsd_readvPtr.asFunction<int Function(int, ffi.Pointer<zts_iovec>, int)>();

  /// @brief Write data from buffer to socket
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of buffer to write
  /// @return Number of bytes written if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_write(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _bsd_write(
      fd,
      buf,
      len,
    );
  }

  late final _bsd_writePtr = _lookup<ffi.NativeFunction<ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('zts_bsd_write');
  late final _bsd_write = _bsd_writePtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// @brief Write data from multiple buffers to socket.
  ///
  /// @param fd Socket file descriptor
  /// @param iov Array of source buffers
  /// @param iovcnt Number of buffers to read from
  /// @return Number of bytes written if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_writev(
    int fd,
    ffi.Pointer<zts_iovec> iov,
    int iovcnt,
  ) {
    return _bsd_writev(
      fd,
      iov,
      iovcnt,
    );
  }

  late final _bsd_writevPtr = _lookup<ffi.NativeFunction<ssize_t Function(ffi.Int, ffi.Pointer<zts_iovec>, ffi.Int)>>('zts_bsd_writev');
  late final _bsd_writev = _bsd_writevPtr.asFunction<int Function(int, ffi.Pointer<zts_iovec>, int)>();

  /// @brief Shut down some aspect of a socket
  ///
  /// @param fd Socket file descriptor
  /// @param how Which aspects of the socket should be shut down. Options are `ZTS_SHUT_RD`,
  /// `ZTS_SHUT_WR`, or `ZTS_SHUT_RDWR`.
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bsd_shutdown(
    int fd,
    int how,
  ) {
    return _bsd_shutdown(
      fd,
      how,
    );
  }

  late final _bsd_shutdownPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('zts_bsd_shutdown');
  late final _bsd_shutdown = _bsd_shutdownPtr.asFunction<int Function(int, int)>();

  /// @brief Create a socket
  ///
  /// @param family `ZTS_AF_INET` or `ZTS_AF_INET6`
  /// @param type `ZTS_SOCK_STREAM` or `ZTS_SOCK_DGRAM`
  /// @param protocol Protocols supported on this socket
  /// @return Numbered file descriptor on success, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int socket(
    int family,
    int type,
    int protocol,
  ) {
    return _socket(
      family,
      type,
      protocol,
    );
  }

  late final _socketPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>('zts_socket');
  late final _socket = _socketPtr.asFunction<int Function(int, int, int)>();

  /// @brief Connect a socket to a remote host
  ///
  /// This convenience function exists because ZeroTier uses transport-triggered
  /// links. This means that links between peers do not exist until peers try to
  /// talk to each other. This can be a problem during connection procedures since
  /// some of the initial packets are lost. To alleviate the need to try
  /// `zts_bsd_connect` many times, this function will keep re-trying for you, even if
  /// no known routes exist. However, if the socket is set to `non-blocking` mode
  /// it will behave identically to `zts_bsd_connect` and return immediately upon
  /// failure.
  ///
  /// @param fd Socket file descriptor
  /// @param ipstr Human-readable IP string
  /// @param port Port
  /// @param timeout_ms (Approximate) amount of time in milliseconds before
  /// connection attempt is aborted. Will block for `30 seconds` if timeout is
  /// set to `0`.
  ///
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SOCKET` if the function times
  /// out with no connection made, `ZTS_ERR_SERVICE` if the node experiences a
  /// problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int connect(
    int fd,
    ffi.Pointer<ffi.Char> ipstr,
    int port,
    int timeout_ms,
  ) {
    return _connect(
      fd,
      ipstr,
      port,
      timeout_ms,
    );
  }

  late final _connectPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.UnsignedShort, ffi.Int)>>('zts_connect');
  late final _connect = _connectPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int)>();

  /// @brief Bind a socket to a local address
  ///
  /// @param fd Socket file descriptor
  /// @param ipstr Human-readable IP string
  /// @param port Port
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int bind(
    int fd,
    ffi.Pointer<ffi.Char> ipstr,
    int port,
  ) {
    return _bind(
      fd,
      ipstr,
      port,
    );
  }

  late final _bindPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.UnsignedShort)>>('zts_bind');
  late final _bind = _bindPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Listen for incoming connections on socket
  ///
  /// @param fd Socket file descriptor
  /// @param backlog Number of backlogged connections allowed
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int listen(
    int fd,
    int backlog,
  ) {
    return _listen(
      fd,
      backlog,
    );
  }

  late final _listenPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('zts_listen');
  late final _listen = _listenPtr.asFunction<int Function(int, int)>();

  /// @brief Accept an incoming connection
  ///
  /// @param fd Socket file descriptor
  /// @param remote_addr Buffer that will receive remote host IP string
  /// @param len Size of buffer that will receive remote host IP string
  /// (must be exactly `ZTS_IP_MAX_STR_LEN`)
  /// @param port Port number of the newly connected remote host (value-result)
  /// @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int accept(
    int fd,
    ffi.Pointer<ffi.Char> remote_addr,
    int len,
    ffi.Pointer<ffi.UnsignedShort> port,
  ) {
    return _accept(
      fd,
      remote_addr,
      len,
      port,
    );
  }

  late final _acceptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<ffi.UnsignedShort>)>>('zts_accept');
  late final _accept = _acceptPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.UnsignedShort>)>();

  /// @brief Send data to remote host
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data to write
  /// @param flags (e.g. `ZTS_MSG_DONTWAIT`, `ZTS_MSG_MORE`)
  /// @return Number of bytes sent if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int send(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
    int flags,
  ) {
    return _send(
      fd,
      buf,
      len,
      flags,
    );
  }

  late final _sendPtr = _lookup<ffi.NativeFunction<ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, ffi.Int)>>('zts_send');
  late final _send = _sendPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  /// @brief Receive data from remote host
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data buffer
  /// @param flags Specifies the type of message receipt
  /// @return Number of bytes received if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int recv(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
    int flags,
  ) {
    return _recv(
      fd,
      buf,
      len,
      flags,
    );
  }

  late final _recvPtr = _lookup<ffi.NativeFunction<ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, ffi.Int)>>('zts_recv');
  late final _recv = _recvPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  /// @brief Read data from socket onto buffer
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data buffer to receive data
  /// @return Number of bytes read if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int read(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _read(
      fd,
      buf,
      len,
    );
  }

  late final _readPtr = _lookup<ffi.NativeFunction<ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('zts_read');
  late final _read = _readPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// @brief Write data from buffer to socket
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of buffer to write
  /// @return Number of bytes written if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int write(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _write(
      fd,
      buf,
      len,
    );
  }

  late final _writePtr = _lookup<ffi.NativeFunction<ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('zts_write');
  late final _write = _writePtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// @brief Shut down `read` aspect of a socket
  ///
  /// @param fd Socket file descriptor
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int shutdown_rd(
    int fd,
  ) {
    return _shutdown_rd(
      fd,
    );
  }

  late final _shutdown_rdPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_shutdown_rd');
  late final _shutdown_rd = _shutdown_rdPtr.asFunction<int Function(int)>();

  /// @brief Shut down `write` aspect of a socket
  ///
  /// @param fd Socket file descriptor
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int shutdown_wr(
    int fd,
  ) {
    return _shutdown_wr(
      fd,
    );
  }

  late final _shutdown_wrPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_shutdown_wr');
  late final _shutdown_wr = _shutdown_wrPtr.asFunction<int Function(int)>();

  /// @brief Shut down both `read` and `write` aspect of a socket
  ///
  /// @param fd Socket file descriptor
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int shutdown_rdwr(
    int fd,
  ) {
    return _shutdown_rdwr(
      fd,
    );
  }

  late final _shutdown_rdwrPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_shutdown_rdwr');
  late final _shutdown_rdwr = _shutdown_rdwrPtr.asFunction<int Function(int)>();

  /// @brief Close socket.
  ///
  /// @param fd Socket file descriptor
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int close(
    int fd,
  ) {
    return _close(
      fd,
    );
  }

  late final _closePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_close');
  late final _close = _closePtr.asFunction<int Function(int)>();

  /// @brief Get the name (address) of the remote end of the socket
  ///
  /// @param fd Socket file descriptor
  /// @param remote_addr_str Destination buffer to contain name (address) of the remote end of the socket
  /// @param len Length of destination buffer
  /// @param port Value-result parameter that will contain resultant port number
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int getpeername(
    int fd,
    ffi.Pointer<ffi.Char> remote_addr_str,
    int len,
    ffi.Pointer<ffi.UnsignedShort> port,
  ) {
    return _getpeername(
      fd,
      remote_addr_str,
      len,
      port,
    );
  }

  late final _getpeernamePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<ffi.UnsignedShort>)>>('zts_getpeername');
  late final _getpeername = _getpeernamePtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.UnsignedShort>)>();

  /// @brief Get the name (address) of the local end of the socket
  ///
  /// @param fd Socket file descriptor
  /// @param local_addr_str Destination buffer to contain name (address) of the local end of the socket
  /// @param len Length of destination buffer
  /// @param port Value-result parameter that will contain resultant port number
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int getsockname(
    int fd,
    ffi.Pointer<ffi.Char> local_addr_str,
    int len,
    ffi.Pointer<ffi.UnsignedShort> port,
  ) {
    return _getsockname(
      fd,
      local_addr_str,
      len,
      port,
    );
  }

  late final _getsocknamePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<ffi.UnsignedShort>)>>('zts_getsockname');
  late final _getsockname = _getsocknamePtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.UnsignedShort>)>();

  /// @brief A convenience function that takes a remote address IP string and creates
  /// the appropriate type of socket, and uses it to connect to a remote host.
  ///
  /// @param remote_ipstr Remote address string. IPv4 or IPv6
  /// @param remote_port Port to
  ///
  /// @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int tcp_client(
    ffi.Pointer<ffi.Char> remote_ipstr,
    int remote_port,
  ) {
    return _tcp_client(
      remote_ipstr,
      remote_port,
    );
  }

  late final _tcp_clientPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.UnsignedShort)>>('zts_tcp_client');
  late final _tcp_client = _tcp_clientPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// @brief A convenience function that takes a remote address IP string and creates
  /// the appropriate type of socket, binds, listens, and then accepts on it.
  ///
  /// @param local_ipstr Local address to bind
  /// @param local_port Local port to bind
  /// @param remote_ipstr String-format IP address of newly connected remote host
  /// @param len Length of `remote_ipstr`
  /// @param remote_port Port of remote host
  ///
  /// @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int tcp_server(
    ffi.Pointer<ffi.Char> local_ipstr,
    int local_port,
    ffi.Pointer<ffi.Char> remote_ipstr,
    int len,
    ffi.Pointer<ffi.UnsignedShort> remote_port,
  ) {
    return _tcp_server(
      local_ipstr,
      local_port,
      remote_ipstr,
      len,
      remote_port,
    );
  }

  late final _tcp_serverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.UnsignedShort, ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<ffi.UnsignedShort>)>>('zts_tcp_server');
  late final _tcp_server =
      _tcp_serverPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.UnsignedShort>)>();

  /// @brief A convenience function that takes a remote address IP string and creates
  /// the appropriate type of socket, and binds to it.
  ///
  /// @param local_ipstr Local address to bind
  /// @param local_port Local port to bind
  ///
  /// @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int udp_server(
    ffi.Pointer<ffi.Char> local_ipstr,
    int local_port,
  ) {
    return _udp_server(
      local_ipstr,
      local_port,
    );
  }

  late final _udp_serverPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.UnsignedShort)>>('zts_udp_server');
  late final _udp_server = _udp_serverPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// @brief This function doesn't really do anything other than be a namespace
  /// counterpart to `zts_udp_server`. All this function does is create a
  /// `ZTS_SOCK_DGRAM` socket and return its file descriptor.
  ///
  /// @param remote_ipstr Remote address string. IPv4 or IPv6
  ///
  /// @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int udp_client(
    ffi.Pointer<ffi.Char> remote_ipstr,
  ) {
    return _udp_client(
      remote_ipstr,
    );
  }

  late final _udp_clientPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>('zts_udp_client');
  late final _udp_client = _udp_clientPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// @brief Enable or disable `TCP_NODELAY`. Enabling this is equivalent to
  /// turning off Nagle's algorithm
  ///
  /// @param fd Socket file descriptor
  /// @param enabled `[0, 1]` integer value
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int set_no_delay(
    int fd,
    int enabled,
  ) {
    return _set_no_delay(
      fd,
      enabled,
    );
  }

  late final _set_no_delayPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('zts_set_no_delay');
  late final _set_no_delay = _set_no_delayPtr.asFunction<int Function(int, int)>();

  /// @brief Get the last error for the given socket
  ///
  /// @param fd Socket file descriptor
  /// @return Error number defined in `zts_errno_t`. `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int get_last_socket_error(
    int fd,
  ) {
    return _get_last_socket_error(
      fd,
    );
  }

  late final _get_last_socket_errorPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_get_last_socket_error');
  late final _get_last_socket_error = _get_last_socket_errorPtr.asFunction<int Function(int)>();

  /// @brief Return amount of data available to read from socket
  ///
  /// @param fd Socket file descriptor
  /// @return Number of bytes available to read. `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int get_data_available(
    int fd,
  ) {
    return _get_data_available(
      fd,
    );
  }

  late final _get_data_availablePtr = _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Int)>>('zts_get_data_available');
  late final _get_data_available = _get_data_availablePtr.asFunction<int Function(int)>();

  /// @brief Return whether `TCP_NODELAY` is enabled
  ///
  /// @param fd Socket file descriptor
  /// @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int get_no_delay(
    int fd,
  ) {
    return _get_no_delay(
      fd,
    );
  }

  late final _get_no_delayPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_get_no_delay');
  late final _get_no_delay = _get_no_delayPtr.asFunction<int Function(int)>();

  /// @brief Enable or disable `SO_LINGER` while also setting its value
  ///
  /// @param fd Socket file descriptor
  /// @param enabled `[0, 1]` integer value
  /// @param value How long socket should linger
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int set_linger(
    int fd,
    int enabled,
    int value,
  ) {
    return _set_linger(
      fd,
      enabled,
      value,
    );
  }

  late final _set_lingerPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>('zts_set_linger');
  late final _set_linger = _set_lingerPtr.asFunction<int Function(int, int, int)>();

  /// @brief Return whether `SO_LINGER` is enabled
  ///
  /// @param fd Socket file descriptor
  /// @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int get_linger_enabled(
    int fd,
  ) {
    return _get_linger_enabled(
      fd,
    );
  }

  late final _get_linger_enabledPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_get_linger_enabled');
  late final _get_linger_enabled = _get_linger_enabledPtr.asFunction<int Function(int)>();

  /// @brief Return the value of `SO_LINGER`
  ///
  /// @param fd Socket file descriptor
  /// @return Value of `SO_LINGER` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int get_linger_value(
    int fd,
  ) {
    return _get_linger_value(
      fd,
    );
  }

  late final _get_linger_valuePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_get_linger_value');
  late final _get_linger_value = _get_linger_valuePtr.asFunction<int Function(int)>();

  /// @brief Return the number of bytes available to read from the network buffer
  ///
  /// @param fd Socket file descriptor
  /// @return Number of bytes to read if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int get_pending_data_size(
    int fd,
  ) {
    return _get_pending_data_size(
      fd,
    );
  }

  late final _get_pending_data_sizePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_get_pending_data_size');
  late final _get_pending_data_size = _get_pending_data_sizePtr.asFunction<int Function(int)>();

  /// @brief Enable or disable `SO_REUSEADDR`
  ///
  /// @param fd Socket file descriptor
  /// @param enabled `[0, 1]` integer value
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int set_reuse_addr(
    int fd,
    int enabled,
  ) {
    return _set_reuse_addr(
      fd,
      enabled,
    );
  }

  late final _set_reuse_addrPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('zts_set_reuse_addr');
  late final _set_reuse_addr = _set_reuse_addrPtr.asFunction<int Function(int, int)>();

  /// @brief Return whether `SO_REUSEADDR` is enabled
  ///
  /// @param fd Socket file descriptor
  /// @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int get_reuse_addr(
    int fd,
  ) {
    return _get_reuse_addr(
      fd,
    );
  }

  late final _get_reuse_addrPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_get_reuse_addr');
  late final _get_reuse_addr = _get_reuse_addrPtr.asFunction<int Function(int)>();

  /// @brief Set the value of `SO_RCVTIMEO`
  ///
  /// @param fd Socket file descriptor
  /// @param seconds Number of seconds for timeout
  /// @param microseconds Number of microseconds for timeout
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int set_recv_timeout(
    int fd,
    int seconds,
    int microseconds,
  ) {
    return _set_recv_timeout(
      fd,
      seconds,
      microseconds,
    );
  }

  late final _set_recv_timeoutPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>('zts_set_recv_timeout');
  late final _set_recv_timeout = _set_recv_timeoutPtr.asFunction<int Function(int, int, int)>();

  /// @brief Return the value of `SO_RCVTIMEO`
  ///
  /// @param fd Socket file descriptor
  /// @return Value of `SO_RCVTIMEO` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int get_recv_timeout(
    int fd,
  ) {
    return _get_recv_timeout(
      fd,
    );
  }

  late final _get_recv_timeoutPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_get_recv_timeout');
  late final _get_recv_timeout = _get_recv_timeoutPtr.asFunction<int Function(int)>();

  /// @brief Set the value of `SO_SNDTIMEO`
  ///
  /// @param fd Socket file descriptor
  /// @param seconds Number of seconds for timeout
  /// @param microseconds Number of microseconds for timeout
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int set_send_timeout(
    int fd,
    int seconds,
    int microseconds,
  ) {
    return _set_send_timeout(
      fd,
      seconds,
      microseconds,
    );
  }

  late final _set_send_timeoutPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>('zts_set_send_timeout');
  late final _set_send_timeout = _set_send_timeoutPtr.asFunction<int Function(int, int, int)>();

  /// @brief Return the value of `SO_SNDTIMEO`
  ///
  /// @param fd Socket file descriptor
  /// @return Value of `SO_SNDTIMEO` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int get_send_timeout(
    int fd,
  ) {
    return _get_send_timeout(
      fd,
    );
  }

  late final _get_send_timeoutPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_get_send_timeout');
  late final _get_send_timeout = _get_send_timeoutPtr.asFunction<int Function(int)>();

  /// @brief Set the value of `SO_SNDBUF`
  ///
  /// @param fd Socket file descriptor
  /// @param size Size of buffer
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int set_send_buf_size(
    int fd,
    int size,
  ) {
    return _set_send_buf_size(
      fd,
      size,
    );
  }

  late final _set_send_buf_sizePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('zts_set_send_buf_size');
  late final _set_send_buf_size = _set_send_buf_sizePtr.asFunction<int Function(int, int)>();

  /// @brief Return the value of `SO_SNDBUF`
  ///
  /// @param fd Socket file descriptor
  /// @return Value of `SO_SNDBUF` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int get_send_buf_size(
    int fd,
  ) {
    return _get_send_buf_size(
      fd,
    );
  }

  late final _get_send_buf_sizePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_get_send_buf_size');
  late final _get_send_buf_size = _get_send_buf_sizePtr.asFunction<int Function(int)>();

  /// @brief Set the value of `SO_RCVBUF`
  ///
  /// @param fd Socket file descriptor
  /// @param size Size of buffer
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int set_recv_buf_size(
    int fd,
    int size,
  ) {
    return _set_recv_buf_size(
      fd,
      size,
    );
  }

  late final _set_recv_buf_sizePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('zts_set_recv_buf_size');
  late final _set_recv_buf_size = _set_recv_buf_sizePtr.asFunction<int Function(int, int)>();

  /// @brief Return the value of `SO_RCVBUF`
  ///
  /// @param fd Socket file descriptor
  /// @return Value of `SO_RCVBUF` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int get_recv_buf_size(
    int fd,
  ) {
    return _get_recv_buf_size(
      fd,
    );
  }

  late final _get_recv_buf_sizePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_get_recv_buf_size');
  late final _get_recv_buf_size = _get_recv_buf_sizePtr.asFunction<int Function(int)>();

  /// @brief Set the value of `IP_TTL`
  ///
  /// @param fd Socket file descriptor
  /// @param ttl Value of `IP_TTL`
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int set_ttl(
    int fd,
    int ttl,
  ) {
    return _set_ttl(
      fd,
      ttl,
    );
  }

  late final _set_ttlPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('zts_set_ttl');
  late final _set_ttl = _set_ttlPtr.asFunction<int Function(int, int)>();

  /// @brief Return the value of `IP_TTL`
  ///
  /// @param fd Socket file descriptor
  /// @return Value of `IP_TTL` `[0,255]` if successful, `ZTS_ERR_SERVICE` if the
  /// node experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int get_ttl(
    int fd,
  ) {
    return _get_ttl(
      fd,
    );
  }

  late final _get_ttlPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_get_ttl');
  late final _get_ttl = _get_ttlPtr.asFunction<int Function(int)>();

  /// @brief Change blocking behavior `O_NONBLOCK`
  ///
  /// @param fd Socket file descriptor
  /// @param enabled `[0, 1]` integer value, `1` maintains default behavior,
  /// `0` sets to non-blocking mode
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int set_blocking(
    int fd,
    int enabled,
  ) {
    return _set_blocking(
      fd,
      enabled,
    );
  }

  late final _set_blockingPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('zts_set_blocking');
  late final _set_blocking = _set_blockingPtr.asFunction<int Function(int, int)>();

  /// @brief Return whether blocking mode `O_NONBLOCK` is enabled
  ///
  /// @param fd Socket file descriptor
  /// @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int get_blocking(
    int fd,
  ) {
    return _get_blocking(
      fd,
    );
  }

  late final _get_blockingPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_get_blocking');
  late final _get_blocking = _get_blockingPtr.asFunction<int Function(int)>();

  /// @brief Enable or disable `SO_KEEPALIVE`
  ///
  /// @param fd Socket file descriptor
  /// @param enabled `[0, 1]` integer value
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int set_keepalive(
    int fd,
    int enabled,
  ) {
    return _set_keepalive(
      fd,
      enabled,
    );
  }

  late final _set_keepalivePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('zts_set_keepalive');
  late final _set_keepalive = _set_keepalivePtr.asFunction<int Function(int, int)>();

  /// @brief Return whether `SO_KEEPALIVE` is enabled
  ///
  /// @param fd Socket file descriptor
  /// @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int get_keepalive(
    int fd,
  ) {
    return _get_keepalive(
      fd,
    );
  }

  late final _get_keepalivePtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_get_keepalive');
  late final _get_keepalive = _get_keepalivePtr.asFunction<int Function(int)>();

  /// @brief Resolve a host-name
  ///
  /// @param name A null-terminated string representing the name of the host
  /// @return Pointer to struct zts_hostent if successful, NULL otherwise
  ffi.Pointer<zts_hostent> bsd_gethostbyname(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _bsd_gethostbyname(
      name,
    );
  }

  late final _bsd_gethostbynamePtr = _lookup<ffi.NativeFunction<ffi.Pointer<zts_hostent> Function(ffi.Pointer<ffi.Char>)>>('zts_bsd_gethostbyname');
  late final _bsd_gethostbyname = _bsd_gethostbynamePtr.asFunction<ffi.Pointer<zts_hostent> Function(ffi.Pointer<ffi.Char>)>();

  /// Initialize one of the DNS servers.
  ///
  /// @param index the index of the DNS server to set must be `< DNS_MAX_SERVERS`
  /// @param addr IP address of the DNS server to set
  int dns_set_server(
    int index,
    ffi.Pointer<zts_ip_addr> addr,
  ) {
    return _dns_set_server(
      index,
      addr,
    );
  }

  late final _dns_set_serverPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint8, ffi.Pointer<zts_ip_addr>)>>('zts_dns_set_server');
  late final _dns_set_server = _dns_set_serverPtr.asFunction<int Function(int, ffi.Pointer<zts_ip_addr>)>();

  /// Obtain one of the currently configured DNS server.
  ///
  /// @param index the index of the DNS server
  /// @return IP address of the indexed DNS server or `ip_addr_any` if the DNS
  /// server has not been configured.
  ffi.Pointer<zts_ip_addr> dns_get_server(
    int index,
  ) {
    return _dns_get_server(
      index,
    );
  }

  late final _dns_get_serverPtr = _lookup<ffi.NativeFunction<ffi.Pointer<zts_ip_addr> Function(ffi.Uint8)>>('zts_dns_get_server');
  late final _dns_get_server = _dns_get_serverPtr.asFunction<ffi.Pointer<zts_ip_addr> Function(int)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int core_lock_obtain() {
    return _core_lock_obtain();
  }

  late final _core_lock_obtainPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('zts_core_lock_obtain');
  late final _core_lock_obtain = _core_lock_obtainPtr.asFunction<int Function()>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int core_lock_release() {
    return _core_lock_release();
  }

  late final _core_lock_releasePtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('zts_core_lock_release');
  late final _core_lock_release = _core_lock_releasePtr.asFunction<int Function()>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int core_query_addr_count(
    int net_id,
  ) {
    return _core_query_addr_count(
      net_id,
    );
  }

  late final _core_query_addr_countPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('zts_core_query_addr_count');
  late final _core_query_addr_count = _core_query_addr_countPtr.asFunction<int Function(int)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int core_query_addr(
    int net_id,
    int idx,
    ffi.Pointer<ffi.Char> addr,
    int len,
  ) {
    return _core_query_addr(
      net_id,
      idx,
      addr,
      len,
    );
  }

  late final _core_query_addrPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('zts_core_query_addr');
  late final _core_query_addr = _core_query_addrPtr.asFunction<int Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int core_query_route_count(
    int net_id,
  ) {
    return _core_query_route_count(
      net_id,
    );
  }

  late final _core_query_route_countPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('zts_core_query_route_count');
  late final _core_query_route_count = _core_query_route_countPtr.asFunction<int Function(int)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int core_query_route(
    int net_id,
    int idx,
    ffi.Pointer<ffi.Char> target,
    ffi.Pointer<ffi.Char> via,
    int len,
    ffi.Pointer<ffi.Uint16> flags,
    ffi.Pointer<ffi.Uint16> metric,
  ) {
    return _core_query_route(
      net_id,
      idx,
      target,
      via,
      len,
      flags,
      metric,
    );
  }

  late final _core_query_routePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Uint64, ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.UnsignedInt, ffi.Pointer<ffi.Uint16>,
              ffi.Pointer<ffi.Uint16>)>>('zts_core_query_route');
  late final _core_query_route = _core_query_routePtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Uint16>, ffi.Pointer<ffi.Uint16>)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int core_query_path_count(
    int peer_id,
  ) {
    return _core_query_path_count(
      peer_id,
    );
  }

  late final _core_query_path_countPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('zts_core_query_path_count');
  late final _core_query_path_count = _core_query_path_countPtr.asFunction<int Function(int)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int core_query_path(
    int peer_id,
    int idx,
    ffi.Pointer<ffi.Char> dst,
    int len,
  ) {
    return _core_query_path(
      peer_id,
      idx,
      dst,
      len,
    );
  }

  late final _core_query_pathPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('zts_core_query_path');
  late final _core_query_path = _core_query_pathPtr.asFunction<int Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int core_query_mc_count(
    int net_id,
  ) {
    return _core_query_mc_count(
      net_id,
    );
  }

  late final _core_query_mc_countPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('zts_core_query_mc_count');
  late final _core_query_mc_count = _core_query_mc_countPtr.asFunction<int Function(int)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int core_query_mc(
    int net_id,
    int idx,
    ffi.Pointer<ffi.Uint64> mac,
    ffi.Pointer<ffi.Uint32> adi,
  ) {
    return _core_query_mc(
      net_id,
      idx,
      mac,
      adi,
    );
  }

  late final _core_query_mcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.UnsignedInt, ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Uint32>)>>(
          'zts_core_query_mc');
  late final _core_query_mc = _core_query_mcPtr.asFunction<int Function(int, int, ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Uint32>)>();

  /// @brief Generates a new root set definition
  ///
  /// @param roots_id The desired World ID (arbitrary)
  /// @param ts Timestamp indicating when this generation took place
  int util_sign_root_set(
    ffi.Pointer<ffi.Char> roots_out,
    ffi.Pointer<ffi.UnsignedInt> roots_len,
    ffi.Pointer<ffi.Char> prev_key,
    ffi.Pointer<ffi.UnsignedInt> prev_key_len,
    ffi.Pointer<ffi.Char> curr_key,
    ffi.Pointer<ffi.UnsignedInt> curr_key_len,
    int id,
    int ts,
    ffi.Pointer<zts_root_set_t> roots_spec,
  ) {
    return _util_sign_root_set(
      roots_out,
      roots_len,
      prev_key,
      prev_key_len,
      curr_key,
      curr_key_len,
      id,
      ts,
      roots_spec,
    );
  }

  late final _util_sign_root_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>, ffi.Uint64, ffi.Uint64, ffi.Pointer<zts_root_set_t>)>>('zts_util_sign_root_set');
  late final _util_sign_root_set = _util_sign_root_setPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.UnsignedInt>, int, int, ffi.Pointer<zts_root_set_t>)>();

  /// @brief Platform-agnostic delay
  ///
  /// @param milliseconds How long to delay
  void util_delay(
    int milliseconds,
  ) {
    return _util_delay(
      milliseconds,
    );
  }

  late final _util_delayPtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedLong)>>('zts_util_delay');
  late final _util_delay = _util_delayPtr.asFunction<void Function(int)>();

  /// @brief Return the family type of the IP string
  ///
  /// @param ipstr Either IPv4 or IPv6 string
  /// @return Either `ZTS_AF_INET` or `ZTS_AF_INET6`
  int util_get_ip_family(
    ffi.Pointer<ffi.Char> ipstr,
  ) {
    return _util_get_ip_family(
      ipstr,
    );
  }

  late final _util_get_ip_familyPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>('zts_util_get_ip_family');
  late final _util_get_ip_family = _util_get_ip_familyPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Convert human-friendly IP string to `zts_sockaddr_in` or `zts_sockaddr_in6`.
  ///
  /// @param src_ipstr Source IP string
  /// @param port Port
  /// @param dstaddr Pointer to destination structure `zts_sockaddr_in` or
  /// `zts_sockaddr_in6`
  /// @param addrlen Size of destination structure. Value-result: Will be set to
  /// actual size of data available
  /// @return return `ZTS_ERR_OK` on success, `ZTS_ERR_ARG` if invalid argument
  int util_ipstr_to_saddr(
    ffi.Pointer<ffi.Char> src_ipstr,
    int port,
    ffi.Pointer<zts_sockaddr> dstaddr,
    ffi.Pointer<zts_socklen_t> addrlen,
  ) {
    return _util_ipstr_to_saddr(
      src_ipstr,
      port,
      dstaddr,
      addrlen,
    );
  }

  late final _util_ipstr_to_saddrPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.UnsignedShort, ffi.Pointer<zts_sockaddr>, ffi.Pointer<zts_socklen_t>)>>(
          'zts_util_ipstr_to_saddr');
  late final _util_ipstr_to_saddr =
      _util_ipstr_to_saddrPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<zts_sockaddr>, ffi.Pointer<zts_socklen_t>)>();

  /// @brief Similar to `inet_ntop` but determines family automatically and returns
  /// port as a value result parameter.
  ///
  /// @param addr Pointer to address structure
  /// @param addrlen Length of address structure
  /// @param dst_str Destination buffer
  /// @param len Length of destination buffer
  /// @param port Value-result parameter that will contain resultant port number
  ///
  /// @return return `ZTS_ERR_OK` on success, `ZTS_ERR_ARG` if invalid argument
  int util_ntop(
    ffi.Pointer<zts_sockaddr> addr,
    int addrlen,
    ffi.Pointer<ffi.Char> dst_str,
    int len,
    ffi.Pointer<ffi.UnsignedShort> port,
  ) {
    return _util_ntop(
      addr,
      addrlen,
      dst_str,
      len,
      port,
    );
  }

  late final _util_ntopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<zts_sockaddr>, zts_socklen_t, ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<ffi.UnsignedShort>)>>('zts_util_ntop');
  late final _util_ntop =
      _util_ntopPtr.asFunction<int Function(ffi.Pointer<zts_sockaddr>, int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.UnsignedShort>)>();

  /// Convert numeric IP address (both versions) into `ASCII` representation.
  /// returns ptr to static buffer. Not reentrant.
  ///
  /// @param addr IP address in network order to convert
  /// @return Pointer to a global static (!) buffer that holds the `ASCII`
  /// representation of addr
  ffi.Pointer<ffi.Char> ipaddr_ntoa(
    ffi.Pointer<zts_ip_addr> addr,
  ) {
    return _ipaddr_ntoa(
      addr,
    );
  }

  late final _ipaddr_ntoaPtr = _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<zts_ip_addr>)>>('zts_ipaddr_ntoa');
  late final _ipaddr_ntoa = _ipaddr_ntoaPtr.asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<zts_ip_addr>)>();

  /// Convert IP address string (both versions) to numeric.
  /// The version is auto-detected from the string.
  ///
  /// @param cp IP address string to convert
  /// @param addr conversion result is stored here
  /// @return `1` on success, `0` on error
  int ipaddr_aton(
    ffi.Pointer<ffi.Char> cp,
    ffi.Pointer<zts_ip_addr> addr,
  ) {
    return _ipaddr_aton(
      cp,
      addr,
    );
  }

  late final _ipaddr_atonPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<zts_ip_addr>)>>('zts_ipaddr_aton');
  late final _ipaddr_aton = _ipaddr_atonPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<zts_ip_addr>)>();

  /// Convert IPv4 and IPv6 address structures to human-readable text form.
  ///
  /// @param family Address family: `ZTS_AF_INET` or `ZTS_AF_INET6`
  /// @param src Pointer to source address structure
  /// @param dst Pointer to destination character array
  /// @param size Size of the destination buffer
  /// @return On success, returns a non-null pointer to the destination character
  /// array
  ffi.Pointer<ffi.Char> inet_ntop(
    int family,
    ffi.Pointer<ffi.Void> src,
    ffi.Pointer<ffi.Char> dst,
    int size,
  ) {
    return _inet_ntop(
      family,
      src,
      dst,
      size,
    );
  }

  late final _inet_ntopPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, zts_socklen_t)>>(
          'zts_inet_ntop');
  late final _inet_ntop = _inet_ntopPtr.asFunction<ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int)>();

  /// Convert C-string IPv4 and IPv6 addresses to binary form.
  ///
  /// @param family Address family: `ZTS_AF_INET` or `ZTS_AF_INET6`
  /// @param src Pointer to source character array
  /// @param dst Pointer to destination address structure
  /// @return return `1` on success. `0` or `-1` on failure. (Does not follow regular
  /// `zts_*` conventions)
  int inet_pton(
    int family,
    ffi.Pointer<ffi.Char> src,
    ffi.Pointer<ffi.Void> dst,
  ) {
    return _inet_pton(
      family,
      src,
      dst,
    );
  }

  late final _inet_ptonPtr = _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>>('zts_inet_pton');
  late final _inet_pton = _inet_ptonPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>();
}

/// Common error return values
abstract class zts_error_t {
  /// No error
  static const int ZTS_ERR_OK = 0;

  /// Socket error, see `zts_errno`
  static const int ZTS_ERR_SOCKET = -1;

  /// This operation is not allowed at this time. Or possibly the node hasn't been started
  static const int ZTS_ERR_SERVICE = -2;

  /// Invalid argument
  static const int ZTS_ERR_ARG = -3;

  /// No result (not necessarily an error)
  static const int ZTS_ERR_NO_RESULT = -4;

  /// Consider filing a bug report
  static const int ZTS_ERR_GENERAL = -5;
}

/// Event codes used by the (optional) callback API
abstract class zts_event_t {
  /// Node has been initialized
  ///
  /// This is the first event generated, and is always sent. It may occur
  /// before node's constructor returns.
  static const int ZTS_EVENT_NODE_UP = 200;

  /// Node is online -- at least one upstream node appears reachable
  static const int ZTS_EVENT_NODE_ONLINE = 201;

  /// Node is offline -- network does not seem to be reachable by any available
  /// strategy
  static const int ZTS_EVENT_NODE_OFFLINE = 202;

  /// Node is shutting down
  ///
  /// This is generated within Node's destructor when it is being shut down.
  /// It's done for convenience, since cleaning up other state in the event
  /// handler may appear more idiomatic.
  static const int ZTS_EVENT_NODE_DOWN = 203;

  /// A fatal error has occurred. One possible reason is:
  ///
  /// Your identity has collided with another node's ZeroTier address
  ///
  /// This happens if two different public keys both hash (via the algorithm
  /// in Identity::generate()) to the same 40-bit ZeroTier address.
  ///
  /// This is something you should "never" see, where "never" is defined as
  /// once per 2^39 new node initializations / identity creations. If you do
  /// see it, you're going to see it very soon after a node is first
  /// initialized.
  ///
  /// This is reported as an event rather than a return code since it's
  /// detected asynchronously via error messages from authoritative nodes.
  ///
  /// If this occurs, you must shut down and delete the node, delete the
  /// identity.secret record/file from the data store, and restart to generate
  /// a new identity. If you don't do this, you will not be able to communicate
  /// with other nodes.
  ///
  /// We'd automate this process, but we don't think silently deleting
  /// private keys or changing our address without telling the calling code
  /// is good form. It violates the principle of least surprise.
  ///
  /// You can technically get away with not handling this, but we recommend
  /// doing so in a mature reliable application. Besides, handling this
  /// condition is a good way to make sure it never arises. It's like how
  /// umbrellas prevent rain and smoke detectors prevent fires. They do, right?
  ///
  /// Meta-data: none
  static const int ZTS_EVENT_NODE_FATAL_ERROR = 204;

  /// Network ID does not correspond to a known network
  static const int ZTS_EVENT_NETWORK_NOT_FOUND = 210;

  /// The version of ZeroTier inside libzt is too old
  static const int ZTS_EVENT_NETWORK_CLIENT_TOO_OLD = 211;

  /// The configuration for a network has been requested (no action needed)
  static const int ZTS_EVENT_NETWORK_REQ_CONFIG = 212;

  /// The node joined the network successfully (no action needed)
  static const int ZTS_EVENT_NETWORK_OK = 213;

  /// The node is not allowed to join the network (you must authorize node)
  static const int ZTS_EVENT_NETWORK_ACCESS_DENIED = 214;

  /// The node has received an IPv4 address from the network controller
  static const int ZTS_EVENT_NETWORK_READY_IP4 = 215;

  /// The node has received an IPv6 address from the network controller
  static const int ZTS_EVENT_NETWORK_READY_IP6 = 216;

  /// Deprecated
  static const int ZTS_EVENT_NETWORK_READY_IP4_IP6 = 217;

  /// Network controller is unreachable
  static const int ZTS_EVENT_NETWORK_DOWN = 218;

  /// Network change received from controller
  static const int ZTS_EVENT_NETWORK_UPDATE = 219;

  /// TCP/IP stack (lwIP) is up (for debug purposes)
  static const int ZTS_EVENT_STACK_UP = 220;

  /// TCP/IP stack (lwIP) id down (for debug purposes)
  static const int ZTS_EVENT_STACK_DOWN = 221;

  /// lwIP netif up (for debug purposes)
  static const int ZTS_EVENT_NETIF_UP = 230;

  /// lwIP netif down (for debug purposes)
  static const int ZTS_EVENT_NETIF_DOWN = 231;

  /// lwIP netif removed (for debug purposes)
  static const int ZTS_EVENT_NETIF_REMOVED = 232;

  /// lwIP netif link up (for debug purposes)
  static const int ZTS_EVENT_NETIF_LINK_UP = 233;

  /// lwIP netif link down (for debug purposes)
  static const int ZTS_EVENT_NETIF_LINK_DOWN = 234;

  /// A direct P2P path to peer is known
  static const int ZTS_EVENT_PEER_DIRECT = 240;

  /// A direct P2P path to peer is NOT known. Traffic is now relayed
  static const int ZTS_EVENT_PEER_RELAY = 241;

  /// A peer is unreachable. Check NAT/Firewall settings
  static const int ZTS_EVENT_PEER_UNREACHABLE = 242;

  /// A new path to a peer was discovered
  static const int ZTS_EVENT_PEER_PATH_DISCOVERED = 243;

  /// A known path to a peer is now considered dead
  static const int ZTS_EVENT_PEER_PATH_DEAD = 244;

  /// A new managed network route was added
  static const int ZTS_EVENT_ROUTE_ADDED = 250;

  /// A managed network route was removed
  static const int ZTS_EVENT_ROUTE_REMOVED = 251;

  /// A new managed IPv4 address was assigned to this peer
  static const int ZTS_EVENT_ADDR_ADDED_IP4 = 260;

  /// A managed IPv4 address assignment was removed from this peer
  static const int ZTS_EVENT_ADDR_REMOVED_IP4 = 261;

  /// A new managed IPv4 address was assigned to this peer
  static const int ZTS_EVENT_ADDR_ADDED_IP6 = 262;

  /// A managed IPv6 address assignment was removed from this peer
  static const int ZTS_EVENT_ADDR_REMOVED_IP6 = 263;

  /// The node's secret key (identity)
  static const int ZTS_EVENT_STORE_IDENTITY_SECRET = 270;

  /// The node's public key (identity)
  static const int ZTS_EVENT_STORE_IDENTITY_PUBLIC = 271;

  /// The node has received an updated planet config
  static const int ZTS_EVENT_STORE_PLANET = 272;

  /// New reachability hints and peer configuration
  static const int ZTS_EVENT_STORE_PEER = 273;

  /// New network config
  static const int ZTS_EVENT_STORE_NETWORK = 274;
}

abstract class zts_errno_t {
  /// Operation not permitted
  static const int ZTS_EPERM = 1;

  /// No such file or directory
  static const int ZTS_ENOENT = 2;

  /// No such process
  static const int ZTS_ESRCH = 3;

  /// Interrupted system call
  static const int ZTS_EINTR = 4;

  /// I/O error
  static const int ZTS_EIO = 5;

  /// No such device or address
  static const int ZTS_ENXIO = 6;

  /// Bad file number
  static const int ZTS_EBADF = 9;

  /// Try again
  static const int ZTS_EAGAIN = 11;

  /// Operation would block
  static const int ZTS_EWOULDBLOCK = 11;

  /// Out of memory
  static const int ZTS_ENOMEM = 12;

  /// Permission denied
  static const int ZTS_EACCES = 13;

  /// Bad address
  static const int ZTS_EFAULT = 14;

  /// Device or resource busy
  static const int ZTS_EBUSY = 16;

  /// File exists
  static const int ZTS_EEXIST = 17;

  /// No such device
  static const int ZTS_ENODEV = 19;

  /// Invalid argument
  static const int ZTS_EINVAL = 22;

  /// File table overflow
  static const int ZTS_ENFILE = 23;

  /// Too many open files
  static const int ZTS_EMFILE = 24;

  /// Function not implemented
  static const int ZTS_ENOSYS = 38;

  /// Socket operation on non-socket
  static const int ZTS_ENOTSOCK = 88;

  /// Destination address required
  static const int ZTS_EDESTADDRREQ = 89;

  /// Message too long
  static const int ZTS_EMSGSIZE = 90;

  /// Protocol wrong type for socket
  static const int ZTS_EPROTOTYPE = 91;

  /// Protocol not available
  static const int ZTS_ENOPROTOOPT = 92;

  /// Protocol not supported
  static const int ZTS_EPROTONOSUPPORT = 93;

  /// Socket type not supported
  static const int ZTS_ESOCKTNOSUPPORT = 94;

  /// Operation not supported on transport endpoint
  static const int ZTS_EOPNOTSUPP = 95;

  /// Protocol family not supported
  static const int ZTS_EPFNOSUPPORT = 96;

  /// Address family not supported by protocol
  static const int ZTS_EAFNOSUPPORT = 97;

  /// Address already in use
  static const int ZTS_EADDRINUSE = 98;

  /// Cannot assign requested address
  static const int ZTS_EADDRNOTAVAIL = 99;

  /// Network is down
  static const int ZTS_ENETDOWN = 100;

  /// Network is unreachable
  static const int ZTS_ENETUNREACH = 101;

  /// Software caused connection abort
  static const int ZTS_ECONNABORTED = 103;

  /// Connection reset by peer
  static const int ZTS_ECONNRESET = 104;

  /// No buffer space available
  static const int ZTS_ENOBUFS = 105;

  /// Transport endpoint is already connected
  static const int ZTS_EISCONN = 106;

  /// Transport endpoint is not connected
  static const int ZTS_ENOTCONN = 107;

  /// Connection timed out
  static const int ZTS_ETIMEDOUT = 110;

  /// Connection refused
  static const int ZTS_ECONNREFUSED = 111;

  /// No route to host
  static const int ZTS_EHOSTUNREACH = 113;

  /// Operation already in progress
  static const int ZTS_EALREADY = 114;

  /// Operation now in progress
  static const int ZTS_EINPROGRESS = 115;
}

typedef va_list = ffi.Pointer<ffi.Char>;

class zts_in_addr extends ffi.Struct {
  @zts_in_addr_t()
  external int S_addr;
}

typedef zts_in_addr_t = ffi.Uint32;

class zts_in6_addr extends ffi.Struct {
  external un un1;
}

class un extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint32> u32_addr;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> u8_addr;
}

/// Address structure to specify an IPv4 endpoint
class zts_sockaddr_in extends ffi.Struct {
  @ffi.Uint8()
  external int sin_len;

  @zts_sa_family_t()
  external int sin_family;

  @zts_in_port_t()
  external int sin_port;

  external zts_in_addr sin_addr;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> sin_zero;
}

typedef zts_sa_family_t = ffi.Uint8;
typedef zts_in_port_t = ffi.Uint16;

/// Address structure to specify an IPv6 endpoint
class zts_sockaddr_in6 extends ffi.Struct {
  /// length of this structure
  @ffi.Uint8()
  external int sin6_len;

  /// ZTS_AF_INET6
  @zts_sa_family_t()
  external int sin6_family;

  /// Transport layer port #
  @zts_in_port_t()
  external int sin6_port;

  /// IPv6 flow information
  @ffi.Uint32()
  external int sin6_flowinfo;

  /// IPv6 address
  external zts_in6_addr sin6_addr;

  /// Set of interfaces for scope
  @ffi.Uint32()
  external int sin6_scope_id;
}

/// Pointers to socket address structures are often cast to this type
class zts_sockaddr extends ffi.Struct {
  @ffi.Uint8()
  external int sa_len;

  @zts_sa_family_t()
  external int sa_family;

  @ffi.Array.multi([14])
  external ffi.Array<ffi.Char> sa_data;
}

/// Address structure large enough to hold IPv4 and IPv6 addresses
class zts_sockaddr_storage extends ffi.Struct {
  @ffi.Uint8()
  external int s2_len;

  @zts_sa_family_t()
  external int ss_family;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Char> s2_data1;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint32> s2_data2;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint32> s2_data3;
}

/// Runtime details about the current node
class zts_node_info_t extends ffi.Struct {
  /// Node ID
  @ffi.Uint64()
  external int node_id;

  /// Port used by ZeroTier to send and receive traffic
  @ffi.Uint16()
  external int port_primary;

  /// Port used by ZeroTier to send and receive traffic
  @ffi.Uint16()
  external int port_secondary;

  /// Port used by ZeroTier to send and receive traffic
  @ffi.Uint16()
  external int port_tertiary;

  /// ZT Major version
  @ffi.Uint8()
  external int ver_major;

  /// ZT Minor version
  @ffi.Uint8()
  external int ver_minor;

  /// ZT Patch revision
  @ffi.Uint8()
  external int ver_rev;
}

/// Details about an assigned address that was added or removed
class zts_addr_info_t extends ffi.Struct {
  @ffi.Uint64()
  external int net_id;

  external zts_sockaddr_storage addr;
}

/// Virtual network status codes
abstract class zts_network_status_t {
  /// Waiting for network configuration (also means revision == 0)
  static const int ZTS_NETWORK_STATUS_REQUESTING_CONFIGURATION = 0;

  /// Configuration received and we are authorized
  static const int ZTS_NETWORK_STATUS_OK = 1;

  /// Netconf master told us 'nope'
  static const int ZTS_NETWORK_STATUS_ACCESS_DENIED = 2;

  /// Netconf master exists, but this virtual network does not
  static const int ZTS_NETWORK_STATUS_NOT_FOUND = 3;

  /// Initialization of network failed or other internal error
  static const int ZTS_NETWORK_STATUS_PORT_ERROR = 4;

  /// ZeroTier core version too old
  static const int ZTS_NETWORK_STATUS_CLIENT_TOO_OLD = 5;
}

/// Virtual network type codes
abstract class zts_net_info_type_t {
  /// Private networks are authorized via certificates of membership
  static const int ZTS_NETWORK_TYPE_PRIVATE = 0;

  /// Public networks have no access control -- they'll always be AUTHORIZED
  static const int ZTS_NETWORK_TYPE_PUBLIC = 1;
}

/// A route to be pushed on a virtual network
class zts_route_info_t extends ffi.Struct {
  /// Target network / netmask bits (in port field) or NULL or 0.0.0.0/0
  /// for default
  external zts_sockaddr_storage target;

  /// Gateway IP address (port ignored) or NULL (family == 0) for LAN-local
  /// (no gateway)
  external zts_sockaddr_storage via;

  /// Route flags
  @ffi.Uint16()
  external int flags;

  /// Route metric (not currently used)
  @ffi.Uint16()
  external int metric;
}

/// An Ethernet multicast group
class zts_multicast_group_t extends ffi.Struct {
  /// MAC address (least significant 48 bits)
  @ffi.Uint64()
  external int mac;

  /// Additional distinguishing information (usually zero)
  @ffi.UnsignedLong()
  external int adi;
}

/// The peer's trust hierarchy role
abstract class zts_peer_role_t {
  /// Ordinary node
  static const int ZTS_PEER_ROLE_LEAF = 0;

  /// Moon root
  static const int ZTS_PEER_ROLE_MOON = 1;

  /// Planetary root
  static const int ZTS_PEER_ROLE_PLANET = 2;
}

/// Virtual network configuration
class zts_net_info_t extends ffi.Struct {
  /// 64-bit ZeroTier network ID
  @ffi.Uint64()
  external int net_id;

  /// Ethernet MAC (48 bits) that should be assigned to port
  @ffi.Uint64()
  external int mac;

  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> name;

  /// Network configuration request status
  @ffi.Int32()
  external int status;

  /// Network type
  @ffi.Int32()
  external int type;

  /// Maximum interface MTU
  @ffi.UnsignedInt()
  external int mtu;

  /// If nonzero, the network this port belongs to indicates DHCP availability
  ///
  /// This is a suggestion. The underlying implementation is free to ignore it
  /// for security or other reasons. This is simply a netconf parameter that
  /// means 'DHCP is available on this network.'
  @ffi.Int()
  external int dhcp;

  /// If nonzero, this port is allowed to bridge to other networks
  ///
  /// This is informational. If this is false (0), bridged packets will simply
  /// be dropped and bridging won't work.
  @ffi.Int()
  external int bridge;

  /// If nonzero, this network supports and allows broadcast
  /// (ff:ff:ff:ff:ff:ff) traffic
  @ffi.Int()
  external int broadcast_enabled;

  /// If the network is in PORT_ERROR state, this is the (negative) error code
  /// most recently reported
  @ffi.Int()
  external int port_error;

  /// Revision number as reported by controller or 0 if still waiting for
  /// config
  @ffi.UnsignedLong()
  external int netconf_rev;

  /// Number of assigned addresses
  @ffi.UnsignedInt()
  external int assigned_addr_count;

  @ffi.Array.multi([16])
  external ffi.Array<zts_sockaddr_storage> assigned_addrs;

  /// Number of ZT-pushed routes
  @ffi.UnsignedInt()
  external int route_count;

  @ffi.Array.multi([32])
  external ffi.Array<zts_route_info_t> routes;

  /// Number of multicast groups subscribed
  @ffi.UnsignedInt()
  external int multicast_sub_count;

  @ffi.Array.multi([1024])
  external ffi.Array<UnnamedStruct1> multicast_subs;
}

/// Multicast groups to which this network's device is subscribed
class UnnamedStruct1 extends ffi.Struct {
  /// MAC in lower 48 bits
  @ffi.Uint64()
  external int mac;

  /// Additional distinguishing information, usually zero
  /// except for IPv4 ARP groups
  @ffi.Uint32()
  external int adi;
}

/// Physical network path to a peer
class zts_path_t extends ffi.Struct {
  /// Address of endpoint
  external zts_sockaddr_storage address;

  /// Time of last send in milliseconds or 0 for never
  @ffi.Uint64()
  external int last_tx;

  /// Time of last receive in milliseconds or 0 for never
  @ffi.Uint64()
  external int last_rx;

  /// Is this a trusted path? If so this will be its nonzero ID.
  @ffi.Uint64()
  external int trusted_path_id;

  /// One-way latency
  @ffi.Float()
  external double latency;

  @ffi.Float()
  external double unused_0;

  @ffi.Float()
  external double unused_1;

  @ffi.Float()
  external double unused_2;

  @ffi.Float()
  external double unused_3;

  @ffi.Float()
  external double unused_4;

  @ffi.Uint64()
  external int unused_5;

  @ffi.Uint64()
  external int unused_6;

  @ffi.Float()
  external double unused_7;

  /// Name of physical interface (for monitoring)
  external ffi.Pointer<ffi.Char> ifname;

  /// Is path expired?
  @ffi.Int()
  external int expired;

  /// Is path preferred?
  @ffi.Int()
  external int preferred;
}

/// Peer status result buffer
class zts_peer_info_t extends ffi.Struct {
  /// ZeroTier address (40 bits)
  @ffi.Uint64()
  external int peer_id;

  /// Remote major version or -1 if not known
  @ffi.Int()
  external int ver_major;

  /// Remote minor version or -1 if not known
  @ffi.Int()
  external int ver_minor;

  /// Remote revision or -1 if not known
  @ffi.Int()
  external int ver_rev;

  /// Last measured latency in milliseconds or -1 if unknown
  @ffi.Int()
  external int latency;

  /// What trust hierarchy role does this device have?
  @ffi.Int32()
  external int role;

  /// Number of paths (size of paths[])
  @ffi.UnsignedInt()
  external int path_count;

  /// Whether this peer was ever reachable via an aggregate link
  @ffi.Int()
  external int unused_0;

  @ffi.Array.multi([64])
  external ffi.Array<zts_path_t> paths;
}

/// Structure used to specify a root topology (aka a world)
class zts_root_set_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Pointer<ffi.Char>> public_id_str;

  @ffi.Array.multi([16, 32])
  external ffi.Array<ffi.Array<ffi.Pointer<ffi.Char>>> endpoint_ip_str;
}

/// Structure used to convey information about a virtual network
/// interface (netif) to a user application.
class zts_netif_info_t extends ffi.Struct {
  /// The virtual network that this interface was created for
  @ffi.Uint64()
  external int net_id;

  /// The hardware address assigned to this interface
  @ffi.Uint64()
  external int mac;

  /// The MTU for this interface
  @ffi.Int()
  external int mtu;
}

/// Callback message
class zts_event_msg_t extends ffi.Struct {
  /// Event identifier
  @ffi.Int16()
  external int event_code;

  /// Node status
  external ffi.Pointer<zts_node_info_t> node;

  /// Network information
  external ffi.Pointer<zts_net_info_t> network;

  /// Netif status
  external ffi.Pointer<zts_netif_info_t> netif;

  /// Managed routes
  external ffi.Pointer<zts_route_info_t> route;

  /// Peer info
  external ffi.Pointer<zts_peer_info_t> peer;

  /// Assigned address
  external ffi.Pointer<zts_addr_info_t> addr;

  /// Binary data (identities, planets, network configs, peer hints, etc)
  external ffi.Pointer<ffi.Void> cache;

  /// Length of data message or structure
  @ffi.Int()
  external int len;
}

/// Structure containing counters for various protocol statistics
class zts_stats_counter_t extends ffi.Struct {
  /// Number of link packets transmitted
  @ffi.Uint32()
  external int link_tx;

  /// Number of link packets received
  @ffi.Uint32()
  external int link_rx;

  /// Number of link packets dropped
  @ffi.Uint32()
  external int link_drop;

  /// Aggregate number of link-level errors
  @ffi.Uint32()
  external int link_err;

  /// Number of etharp packets transmitted
  @ffi.Uint32()
  external int etharp_tx;

  /// Number of etharp packets received
  @ffi.Uint32()
  external int etharp_rx;

  /// Number of etharp packets dropped
  @ffi.Uint32()
  external int etharp_drop;

  /// Aggregate number of etharp errors
  @ffi.Uint32()
  external int etharp_err;

  /// Number of IPv4 packets transmitted
  @ffi.Uint32()
  external int ip4_tx;

  /// Number of IPv4 packets received
  @ffi.Uint32()
  external int ip4_rx;

  /// Number of IPv4 packets dropped
  @ffi.Uint32()
  external int ip4_drop;

  /// Aggregate number of IPv4 errors
  @ffi.Uint32()
  external int ip4_err;

  /// Number of IPv6 packets transmitted
  @ffi.Uint32()
  external int ip6_tx;

  /// Number of IPv6 packets received
  @ffi.Uint32()
  external int ip6_rx;

  /// Number of IPv6 packets dropped
  @ffi.Uint32()
  external int ip6_drop;

  /// Aggregate number of IPv6 errors
  @ffi.Uint32()
  external int ip6_err;

  /// Number of ICMPv4 packets transmitted
  @ffi.Uint32()
  external int icmp4_tx;

  /// Number of ICMPv4 packets received
  @ffi.Uint32()
  external int icmp4_rx;

  /// Number of ICMPv4 packets dropped
  @ffi.Uint32()
  external int icmp4_drop;

  /// Aggregate number of ICMPv4 errors
  @ffi.Uint32()
  external int icmp4_err;

  /// Number of ICMPv6 packets transmitted
  @ffi.Uint32()
  external int icmp6_tx;

  /// Number of ICMPv6 packets received
  @ffi.Uint32()
  external int icmp6_rx;

  /// Number of ICMPv6 packets dropped
  @ffi.Uint32()
  external int icmp6_drop;

  /// Aggregate number of ICMPv6 errors
  @ffi.Uint32()
  external int icmp6_err;

  /// Number of UDP packets transmitted
  @ffi.Uint32()
  external int udp_tx;

  /// Number of UDP packets received
  @ffi.Uint32()
  external int udp_rx;

  /// Number of UDP packets dropped
  @ffi.Uint32()
  external int udp_drop;

  /// Aggregate number of UDP errors
  @ffi.Uint32()
  external int udp_err;

  /// Number of TCP packets transmitted
  @ffi.Uint32()
  external int tcp_tx;

  /// Number of TCP packets received
  @ffi.Uint32()
  external int tcp_rx;

  /// Number of TCP packets dropped
  @ffi.Uint32()
  external int tcp_drop;

  /// Aggregate number of TCP errors
  @ffi.Uint32()
  external int tcp_err;

  /// Number of ND6 packets transmitted
  @ffi.Uint32()
  external int nd6_tx;

  /// Number of ND6 packets received
  @ffi.Uint32()
  external int nd6_rx;

  /// Number of ND6 packets dropped
  @ffi.Uint32()
  external int nd6_drop;

  /// Aggregate number of ND6 errors
  @ffi.Uint32()
  external int nd6_err;
}

/// ----------------------------------------------------------------------------//
/// Custom but still mostly standard socket interface structures               //
/// ----------------------------------------------------------------------------//
typedef zts_socklen_t = ffi.Uint32;

/// Structure used for manipulating linger option.
class zts_linger extends ffi.Struct {
  /// option on/off
  @ffi.Int()
  external int l_onoff;

  /// linger time in seconds
  @ffi.Int()
  external int l_linger;
}

class zts_ip_mreq extends ffi.Struct {
  /// IP multicast address of group
  external zts_in_addr imr_multiaddr;

  /// local IP address of interface
  external zts_in_addr imr_interface;
}

class zts_in_pktinfo extends ffi.Struct {
  /// Interface index
  @ffi.UnsignedInt()
  external int ipi_ifindex;

  /// Destination (from header) address
  external zts_in_addr ipi_addr;
}

class zts_ipv6_mreq extends ffi.Struct {
  /// IPv6 multicast addr
  external zts_in6_addr ipv6mr_multiaddr;

  /// interface index, or 0
  @ffi.UnsignedInt()
  external int ipv6mr_interface;
}

class zts_fd_set extends ffi.Struct {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.UnsignedChar> fd_bits;
}

class zts_timeval extends ffi.Struct {
  /// seconds
  @ffi.Long()
  external int tv_sec;

  /// and microseconds
  @ffi.Long()
  external int tv_usec;
}

class zts_pollfd extends ffi.Struct {
  @ffi.Int()
  external int fd;

  @ffi.Short()
  external int events;

  @ffi.Short()
  external int revents;
}

typedef zts_nfds_t = ffi.UnsignedInt;

/// TODO: Should be SSIZE_T, would require lwIP patch
/// #include <BaseTsd.h>
/// typedef SSIZE_T ssize_t;
typedef ssize_t = ffi.Int;

class zts_iovec extends ffi.Struct {
  external ffi.Pointer<ffi.Void> iov_base;

  @ffi.Size()
  external int iov_len;
}

///
class zts_msghdr extends ffi.Struct {
  external ffi.Pointer<ffi.Void> msg_name;

  @zts_socklen_t()
  external int msg_namelen;

  external ffi.Pointer<zts_iovec> msg_iov;

  @ffi.Int()
  external int msg_iovlen;

  external ffi.Pointer<ffi.Void> msg_control;

  @zts_socklen_t()
  external int msg_controllen;

  @ffi.Int()
  external int msg_flags;
}

/// ----------------------------------------------------------------------------//
/// DNS                                                                        //
/// ----------------------------------------------------------------------------//
class zts_hostent extends ffi.Struct {
  /// Official name of the host.
  external ffi.Pointer<ffi.Char> h_name;

  /// A pointer to an array of pointers to alternative host
  /// names,   terminated by a null pointer.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> h_aliases;

  /// Address type.
  @ffi.Int()
  external int h_addrtype;

  /// The length, in bytes, of the address.
  @ffi.Int()
  external int h_length;

  /// A pointer to an array of pointers to network
  /// addresses (in network byte order) for the host,
  /// terminated by a null pointer.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> h_addr_list;
}

class zts_ip4_addr extends ffi.Struct {
  @ffi.Uint32()
  external int addr;
}

/// This is the aligned version of ip6_addr_t,
/// used as local variable, on the stack, etc.
class zts_ip6_addr extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint32> addr;
}

/// A union struct for both IP version's addresses.
/// ATTENTION: watch out for its size when adding IPv6 address scope!
class zts_ip_addr extends ffi.Struct {
  external UnnamedUnion1 u_addr;

  /// ZTS_IPADDR_TYPE_V4, ZTS_IPADDR_TYPE_V6
  @ffi.Uint8()
  external int type;
}

class UnnamedUnion1 extends ffi.Union {
  external zts_ip6_addr ip6;

  external zts_ip4_addr ip4;
}

const int ZTS_MAC_ADDRSTRLEN = 18;

const int ZTS_INET_ADDRSTRLEN = 16;

const int ZTS_INET6_ADDRSTRLEN = 46;

const int ZTS_IP_MAX_STR_LEN = 46;

const int ZTS_STORE_DATA_LEN = 4096;

const int ZTS_MAX_NETWORK_SHORT_NAME_LENGTH = 127;

const int ZTS_MAX_NETWORK_ROUTES = 32;

const int ZTS_MAX_ASSIGNED_ADDRESSES = 16;

const int ZTS_MAX_PEER_NETWORK_PATHS = 64;

const int ZTS_MAX_MULTICAST_SUBSCRIPTIONS = 1024;

const int ZTS_MAX_ENDPOINT_STR_LEN = 52;

const int ZTS_C_API_ONLY = 1;

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int _WCHAR_T_DEFINED = 1;

const int NULL = 0;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_CXX23 = 0;

const int _HAS_NODISCARD = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -2147483648;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 2147483647;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 4294967295;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int WCHAR_MIN = 0;

const int WCHAR_MAX = 65535;

const int WINT_MIN = 0;

const int WINT_MAX = 65535;

const int ZTS_IPADDR_NONE = 4294967295;

const int ZTS_IPADDR_LOOPBACK = 2130706433;

const int ZTS_IPADDR_ANY = 0;

const int ZTS_IPADDR_BROADCAST = 4294967295;

const int ZTS_INADDR_NONE = 4294967295;

const int ZTS_INADDR_LOOPBACK = 2130706433;

const int ZTS_INADDR_ANY = 0;

const int ZTS_INADDR_BROADCAST = 4294967295;

const int ZTS_SOCK_STREAM = 1;

const int ZTS_SOCK_DGRAM = 2;

const int ZTS_SOCK_RAW = 3;

const int ZTS_AF_UNSPEC = 0;

const int ZTS_AF_INET = 2;

const int ZTS_AF_INET6 = 10;

const int ZTS_PF_INET = 2;

const int ZTS_PF_INET6 = 10;

const int ZTS_PF_UNSPEC = 0;

const int ZTS_IPPROTO_IP = 0;

const int ZTS_IPPROTO_ICMP = 1;

const int ZTS_IPPROTO_TCP = 6;

const int ZTS_IPPROTO_UDP = 17;

const int ZTS_IPPROTO_IPV6 = 41;

const int ZTS_IPPROTO_ICMPV6 = 58;

const int ZTS_IPPROTO_UDPLITE = 136;

const int ZTS_IPPROTO_RAW = 255;

const int ZTS_MSG_PEEK = 1;

const int ZTS_MSG_WAITALL = 2;

const int ZTS_MSG_OOB = 4;

const int ZTS_MSG_DONTWAIT = 8;

const int ZTS_MSG_MORE = 16;

const int ZTS_IOCPARM_MASK = 127;

const int ZTS_IOC_VOID = 536870912;

const int ZTS_IOC_OUT = 1073741824;

const int ZTS_IOC_IN = 2147483648;

const int ZTS_IOC_INOUT = 3221225472;

const int ZTS_FIONREAD = 1074030207;

const int ZTS_FIONBIO = 2147772030;

const int SIN_ZERO_LEN = 8;

const int ZTS_MAX_NUM_ROOTS = 16;

const int ZTS_MAX_ENDPOINTS_PER_ROOT = 32;

const int ZTS_DISABLE_CENTRAL_API = 1;

const int ZTS_ID_STR_BUF_LEN = 384;

const int ZTS_SOL_SOCKET = 4095;

const int ZTS_SO_DEBUG = 1;

const int ZTS_SO_ACCEPTCONN = 2;

const int ZTS_SO_REUSEADDR = 4;

const int ZTS_SO_KEEPALIVE = 8;

const int ZTS_SO_DONTROUTE = 16;

const int ZTS_SO_BROADCAST = 32;

const int ZTS_SO_USELOOPBACK = 64;

const int ZTS_SO_LINGER = 128;

const int ZTS_SO_DONTLINGER = -129;

const int ZTS_SO_OOBINLINE = 256;

const int ZTS_SO_REUSEPORT = 512;

const int ZTS_SO_SNDBUF = 4097;

const int ZTS_SO_RCVBUF = 4098;

const int ZTS_SO_SNDLOWAT = 4099;

const int ZTS_SO_RCVLOWAT = 4100;

const int ZTS_SO_SNDTIMEO = 4101;

const int ZTS_SO_RCVTIMEO = 4102;

const int ZTS_SO_ERROR = 4103;

const int ZTS_SO_TYPE = 4104;

const int ZTS_SO_CONTIMEO = 4105;

const int ZTS_SO_NO_CHECK = 4106;

const int ZTS_SO_BINDTODEVICE = 4107;

const int ZTS_IP_TOS = 1;

const int ZTS_IP_TTL = 2;

const int ZTS_IP_PKTINFO = 8;

const int ZTS_TCP_NODELAY = 1;

const int ZTS_TCP_KEEPALIVE = 2;

const int ZTS_TCP_KEEPIDLE = 3;

const int ZTS_TCP_KEEPINTVL = 4;

const int ZTS_TCP_KEEPCNT = 5;

const int ZTS_IPV6_CHECKSUM = 7;

const int ZTS_IPV6_V6ONLY = 27;

const int ZTS_UDPLITE_SEND_CSCOV = 1;

const int ZTS_UDPLITE_RECV_CSCOV = 2;

const int ZTS_IP_MULTICAST_TTL = 5;

const int ZTS_IP_MULTICAST_IF = 6;

const int ZTS_IP_MULTICAST_LOOP = 7;

const int ZTS_IP_ADD_MEMBERSHIP = 3;

const int ZTS_IP_DROP_MEMBERSHIP = 4;

const int ZTS_IPV6_JOIN_GROUP = 12;

const int ZTS_IPV6_ADD_MEMBERSHIP = 12;

const int ZTS_IPV6_LEAVE_GROUP = 13;

const int ZTS_IPV6_DROP_MEMBERSHIP = 13;

const int ZTS_IPTOS_TOS_MASK = 30;

const int ZTS_IPTOS_LOWDELAY = 16;

const int ZTS_IPTOS_THROUGHPUT = 8;

const int ZTS_IPTOS_RELIABILITY = 4;

const int ZTS_IPTOS_LOWCOST = 2;

const int ZTS_IPTOS_MINCOST = 2;

const int ZTS_IPTOS_PREC_MASK = 224;

const int ZTS_IPTOS_PREC_NETCONTROL = 224;

const int ZTS_IPTOS_PREC_INTERNETCONTROL = 192;

const int ZTS_IPTOS_PREC_CRITIC_ECP = 160;

const int ZTS_IPTOS_PREC_FLASHOVERRIDE = 128;

const int ZTS_IPTOS_PREC_FLASH = 96;

const int ZTS_IPTOS_PREC_IMMEDIATE = 64;

const int ZTS_IPTOS_PREC_PRIORITY = 32;

const int ZTS_IPTOS_PREC_ROUTINE = 0;

const int LWIP_SOCKET_OFFSET = 0;

const int MEMP_NUM_NETCONN = 1024;

const int ZTS_FD_SETSIZE = 1024;

const int ZTS_F_GETFL = 3;

const int ZTS_F_SETFL = 4;

const int ZTS_O_NONBLOCK = 1;

const int ZTS_O_NDELAY = 1;

const int ZTS_O_RDONLY = 2;

const int ZTS_O_WRONLY = 4;

const int ZTS_O_RDWR = 6;

const int ZTS_POLLIN = 1;

const int ZTS_POLLOUT = 2;

const int ZTS_POLLERR = 4;

const int ZTS_POLLNVAL = 8;

const int ZTS_POLLRDNORM = 16;

const int ZTS_POLLRDBAND = 32;

const int ZTS_POLLPRI = 64;

const int ZTS_POLLWRNORM = 128;

const int ZTS_POLLWRBAND = 256;

const int ZTS_POLLHUP = 512;

const int ZTS_MSG_TRUNC = 4;

const int ZTS_MSG_CTRUNC = 8;

const int ZTS_SHUT_RD = 0;

const int ZTS_SHUT_WR = 1;

const int ZTS_SHUT_RDWR = 2;
